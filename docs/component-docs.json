[
  {
    "name": "GlimAccordion",
    "description": "@component Accordion @description An expandable/collapsible accordion component that displays items with titles and expandable content. Features smooth animations and customizable max-width settings.  @example <Accordion :options=\"[{label: 'Section 1', content: 'This is the content for section 1'}]\" /> @example <Accordion :options=\"accordionItems\" maxWidth=\"600px\" /> @example <Accordion :options=\"faqItems\" maxWidth=\"span 6\" />",
    "props": {},
    "events": {},
    "methods": {
      "accordionStyles": {
        "name": "accordionStyles",
        "description": "@component Accordion @description An expandable/collapsible accordion component that displays items with titles and expandable content. Features smooth animations and customizable max-width settings.  @example <Accordion :options=\"[{label: 'Section 1', content: 'This is the content for section 1'}]\" /> @example <Accordion :options=\"accordionItems\" maxWidth=\"600px\" /> @example <Accordion :options=\"faqItems\" maxWidth=\"span 6\" /> /\nimport { ref, computed } from 'vue'\n\n/   Represents an accordion item with label and content @typedef {Object} AccordionItem @property {string} label - The label displayed in the accordion header @property {string} content - The content displayed when the accordion is expanded /\nexport interface AccordionItem {\n  /   The label displayed in the accordion header /\n  label: string;\n  \n  /   The content displayed when the accordion is expanded /\n  content: string;\n}\n\n/   Accordion component props @typedef {Object} AccordionProps /\nexport interface AccordionProps {\n  /   Array of accordion items to display @type {AccordionItem[]} @required /\n  options?: AccordionItem[];\n  \n  /   Maximum width of the accordion Can be a CSS value (e.g. '600px'), a number (interpreted as pixels), or a grid column span value (e.g. 'span 6') @type {string|number} /\n  maxWidth?: string | number;\n}\n\nconst props = withDefaults(defineProps<AccordionProps>(), {\n  options: () => [\n    {\n      label: 'Getting Started',\n      content: 'Welcome to our platform! This is a default accordion item that shows when no options are provided.'\n    },\n    {\n      label: 'Features',\n      content: 'Discover our amazing features and how they can help you achieve your goals.'\n    },\n    {\n      label: 'Support',\n      content: 'Need help? Our support team is here to assist you with any questions or concerns.'\n    }\n  ],\n  maxWidth: undefined\n})\n\n/   Computed styles for the accordion based on maxWidth prop Handles different formats of maxWidth (pixels, grid spans, etc.)",
        "params": [
          {
            "name": "(",
            "type": "any",
            "description": "Parameter ( for the method",
            "required": true
          }
        ]
      },
      "startExpand": {
        "name": "startExpand",
        "description": "@component Accordion @description An expandable/collapsible accordion component that displays items with titles and expandable content. Features smooth animations and customizable max-width settings.  @example <Accordion :options=\"[{label: 'Section 1', content: 'This is the content for section 1'}]\" /> @example <Accordion :options=\"accordionItems\" maxWidth=\"600px\" /> @example <Accordion :options=\"faqItems\" maxWidth=\"span 6\" /> /\nimport { ref, computed } from 'vue'\n\n/   Represents an accordion item with label and content @typedef {Object} AccordionItem @property {string} label - The label displayed in the accordion header @property {string} content - The content displayed when the accordion is expanded /\nexport interface AccordionItem {\n  /   The label displayed in the accordion header /\n  label: string;\n  \n  /   The content displayed when the accordion is expanded /\n  content: string;\n}\n\n/   Accordion component props @typedef {Object} AccordionProps /\nexport interface AccordionProps {\n  /   Array of accordion items to display @type {AccordionItem[]} @required /\n  options?: AccordionItem[];\n  \n  /   Maximum width of the accordion Can be a CSS value (e.g. '600px'), a number (interpreted as pixels), or a grid column span value (e.g. 'span 6') @type {string|number} /\n  maxWidth?: string | number;\n}\n\nconst props = withDefaults(defineProps<AccordionProps>(), {\n  options: () => [\n    {\n      label: 'Getting Started',\n      content: 'Welcome to our platform! This is a default accordion item that shows when no options are provided.'\n    },\n    {\n      label: 'Features',\n      content: 'Discover our amazing features and how they can help you achieve your goals.'\n    },\n    {\n      label: 'Support',\n      content: 'Need help? Our support team is here to assist you with any questions or concerns.'\n    }\n  ],\n  maxWidth: undefined\n})\n\n/   Computed styles for the accordion based on maxWidth prop Handles different formats of maxWidth (pixels, grid spans, etc.) /\nconst accordionStyles = computed(() => {\n  if (!props.maxWidth) return {}\n  \n  // If it's a number or ends with 'px', treat as pixel value\n  if (typeof props.maxWidth === 'number' || props.maxWidth.endsWith('px')) {\n    return { maxWidth: typeof props.maxWidth === 'number' ? `${props.maxWidth}px` : props.maxWidth }\n  }\n  \n  // If it's a span value (e.g. 'span 6')\n  if (props.maxWidth.startsWith('span')) {\n    return { gridColumn: props.maxWidth }\n  }\n  \n  return { maxWidth: props.maxWidth }\n})\n\n/   Indices of currently expanded accordion items /\nconst expandedIndices = ref<number[]>([])\n\n/   Index of the item currently being expanded (for animation) /\nconst isExpanding = ref<number | null>(null)\n\n/   Index of the item currently being collapsed (for animation) /\nconst isCollapsing = ref<number | null>(null)\n\n/   Start the expand animation for an accordion item @param {number} index - Index of the item being expanded",
        "params": [
          {
            "name": "index",
            "type": "number",
            "description": "Parameter index for the method",
            "required": true
          }
        ]
      },
      "endExpand": {
        "name": "endExpand",
        "description": "@component Accordion @description An expandable/collapsible accordion component that displays items with titles and expandable content. Features smooth animations and customizable max-width settings.  @example <Accordion :options=\"[{label: 'Section 1', content: 'This is the content for section 1'}]\" /> @example <Accordion :options=\"accordionItems\" maxWidth=\"600px\" /> @example <Accordion :options=\"faqItems\" maxWidth=\"span 6\" /> /\nimport { ref, computed } from 'vue'\n\n/   Represents an accordion item with label and content @typedef {Object} AccordionItem @property {string} label - The label displayed in the accordion header @property {string} content - The content displayed when the accordion is expanded /\nexport interface AccordionItem {\n  /   The label displayed in the accordion header /\n  label: string;\n  \n  /   The content displayed when the accordion is expanded /\n  content: string;\n}\n\n/   Accordion component props @typedef {Object} AccordionProps /\nexport interface AccordionProps {\n  /   Array of accordion items to display @type {AccordionItem[]} @required /\n  options?: AccordionItem[];\n  \n  /   Maximum width of the accordion Can be a CSS value (e.g. '600px'), a number (interpreted as pixels), or a grid column span value (e.g. 'span 6') @type {string|number} /\n  maxWidth?: string | number;\n}\n\nconst props = withDefaults(defineProps<AccordionProps>(), {\n  options: () => [\n    {\n      label: 'Getting Started',\n      content: 'Welcome to our platform! This is a default accordion item that shows when no options are provided.'\n    },\n    {\n      label: 'Features',\n      content: 'Discover our amazing features and how they can help you achieve your goals.'\n    },\n    {\n      label: 'Support',\n      content: 'Need help? Our support team is here to assist you with any questions or concerns.'\n    }\n  ],\n  maxWidth: undefined\n})\n\n/   Computed styles for the accordion based on maxWidth prop Handles different formats of maxWidth (pixels, grid spans, etc.) /\nconst accordionStyles = computed(() => {\n  if (!props.maxWidth) return {}\n  \n  // If it's a number or ends with 'px', treat as pixel value\n  if (typeof props.maxWidth === 'number' || props.maxWidth.endsWith('px')) {\n    return { maxWidth: typeof props.maxWidth === 'number' ? `${props.maxWidth}px` : props.maxWidth }\n  }\n  \n  // If it's a span value (e.g. 'span 6')\n  if (props.maxWidth.startsWith('span')) {\n    return { gridColumn: props.maxWidth }\n  }\n  \n  return { maxWidth: props.maxWidth }\n})\n\n/   Indices of currently expanded accordion items /\nconst expandedIndices = ref<number[]>([])\n\n/   Index of the item currently being expanded (for animation) /\nconst isExpanding = ref<number | null>(null)\n\n/   Index of the item currently being collapsed (for animation) /\nconst isCollapsing = ref<number | null>(null)\n\n/   Start the expand animation for an accordion item @param {number} index - Index of the item being expanded /\nconst startExpand = (index: number) => {\n  isExpanding.value = index\n}\n\n/   End the expand animation"
      },
      "startCollapse": {
        "name": "startCollapse",
        "description": "@component Accordion @description An expandable/collapsible accordion component that displays items with titles and expandable content. Features smooth animations and customizable max-width settings.  @example <Accordion :options=\"[{label: 'Section 1', content: 'This is the content for section 1'}]\" /> @example <Accordion :options=\"accordionItems\" maxWidth=\"600px\" /> @example <Accordion :options=\"faqItems\" maxWidth=\"span 6\" /> /\nimport { ref, computed } from 'vue'\n\n/   Represents an accordion item with label and content @typedef {Object} AccordionItem @property {string} label - The label displayed in the accordion header @property {string} content - The content displayed when the accordion is expanded /\nexport interface AccordionItem {\n  /   The label displayed in the accordion header /\n  label: string;\n  \n  /   The content displayed when the accordion is expanded /\n  content: string;\n}\n\n/   Accordion component props @typedef {Object} AccordionProps /\nexport interface AccordionProps {\n  /   Array of accordion items to display @type {AccordionItem[]} @required /\n  options?: AccordionItem[];\n  \n  /   Maximum width of the accordion Can be a CSS value (e.g. '600px'), a number (interpreted as pixels), or a grid column span value (e.g. 'span 6') @type {string|number} /\n  maxWidth?: string | number;\n}\n\nconst props = withDefaults(defineProps<AccordionProps>(), {\n  options: () => [\n    {\n      label: 'Getting Started',\n      content: 'Welcome to our platform! This is a default accordion item that shows when no options are provided.'\n    },\n    {\n      label: 'Features',\n      content: 'Discover our amazing features and how they can help you achieve your goals.'\n    },\n    {\n      label: 'Support',\n      content: 'Need help? Our support team is here to assist you with any questions or concerns.'\n    }\n  ],\n  maxWidth: undefined\n})\n\n/   Computed styles for the accordion based on maxWidth prop Handles different formats of maxWidth (pixels, grid spans, etc.) /\nconst accordionStyles = computed(() => {\n  if (!props.maxWidth) return {}\n  \n  // If it's a number or ends with 'px', treat as pixel value\n  if (typeof props.maxWidth === 'number' || props.maxWidth.endsWith('px')) {\n    return { maxWidth: typeof props.maxWidth === 'number' ? `${props.maxWidth}px` : props.maxWidth }\n  }\n  \n  // If it's a span value (e.g. 'span 6')\n  if (props.maxWidth.startsWith('span')) {\n    return { gridColumn: props.maxWidth }\n  }\n  \n  return { maxWidth: props.maxWidth }\n})\n\n/   Indices of currently expanded accordion items /\nconst expandedIndices = ref<number[]>([])\n\n/   Index of the item currently being expanded (for animation) /\nconst isExpanding = ref<number | null>(null)\n\n/   Index of the item currently being collapsed (for animation) /\nconst isCollapsing = ref<number | null>(null)\n\n/   Start the expand animation for an accordion item @param {number} index - Index of the item being expanded /\nconst startExpand = (index: number) => {\n  isExpanding.value = index\n}\n\n/   End the expand animation /\nconst endExpand = () => {\n  isExpanding.value = null\n}\n\n/   Start the collapse animation for an accordion item @param {number} index - Index of the item being collapsed",
        "params": [
          {
            "name": "index",
            "type": "number",
            "description": "Parameter index for the method",
            "required": true
          }
        ]
      },
      "endCollapse": {
        "name": "endCollapse",
        "description": "@component Accordion @description An expandable/collapsible accordion component that displays items with titles and expandable content. Features smooth animations and customizable max-width settings.  @example <Accordion :options=\"[{label: 'Section 1', content: 'This is the content for section 1'}]\" /> @example <Accordion :options=\"accordionItems\" maxWidth=\"600px\" /> @example <Accordion :options=\"faqItems\" maxWidth=\"span 6\" /> /\nimport { ref, computed } from 'vue'\n\n/   Represents an accordion item with label and content @typedef {Object} AccordionItem @property {string} label - The label displayed in the accordion header @property {string} content - The content displayed when the accordion is expanded /\nexport interface AccordionItem {\n  /   The label displayed in the accordion header /\n  label: string;\n  \n  /   The content displayed when the accordion is expanded /\n  content: string;\n}\n\n/   Accordion component props @typedef {Object} AccordionProps /\nexport interface AccordionProps {\n  /   Array of accordion items to display @type {AccordionItem[]} @required /\n  options?: AccordionItem[];\n  \n  /   Maximum width of the accordion Can be a CSS value (e.g. '600px'), a number (interpreted as pixels), or a grid column span value (e.g. 'span 6') @type {string|number} /\n  maxWidth?: string | number;\n}\n\nconst props = withDefaults(defineProps<AccordionProps>(), {\n  options: () => [\n    {\n      label: 'Getting Started',\n      content: 'Welcome to our platform! This is a default accordion item that shows when no options are provided.'\n    },\n    {\n      label: 'Features',\n      content: 'Discover our amazing features and how they can help you achieve your goals.'\n    },\n    {\n      label: 'Support',\n      content: 'Need help? Our support team is here to assist you with any questions or concerns.'\n    }\n  ],\n  maxWidth: undefined\n})\n\n/   Computed styles for the accordion based on maxWidth prop Handles different formats of maxWidth (pixels, grid spans, etc.) /\nconst accordionStyles = computed(() => {\n  if (!props.maxWidth) return {}\n  \n  // If it's a number or ends with 'px', treat as pixel value\n  if (typeof props.maxWidth === 'number' || props.maxWidth.endsWith('px')) {\n    return { maxWidth: typeof props.maxWidth === 'number' ? `${props.maxWidth}px` : props.maxWidth }\n  }\n  \n  // If it's a span value (e.g. 'span 6')\n  if (props.maxWidth.startsWith('span')) {\n    return { gridColumn: props.maxWidth }\n  }\n  \n  return { maxWidth: props.maxWidth }\n})\n\n/   Indices of currently expanded accordion items /\nconst expandedIndices = ref<number[]>([])\n\n/   Index of the item currently being expanded (for animation) /\nconst isExpanding = ref<number | null>(null)\n\n/   Index of the item currently being collapsed (for animation) /\nconst isCollapsing = ref<number | null>(null)\n\n/   Start the expand animation for an accordion item @param {number} index - Index of the item being expanded /\nconst startExpand = (index: number) => {\n  isExpanding.value = index\n}\n\n/   End the expand animation /\nconst endExpand = () => {\n  isExpanding.value = null\n}\n\n/   Start the collapse animation for an accordion item @param {number} index - Index of the item being collapsed /\nconst startCollapse = (index: number) => {\n  isCollapsing.value = index\n}\n\n/   End the collapse animation"
      },
      "toggleItem": {
        "name": "toggleItem",
        "description": "@component Accordion @description An expandable/collapsible accordion component that displays items with titles and expandable content. Features smooth animations and customizable max-width settings.  @example <Accordion :options=\"[{label: 'Section 1', content: 'This is the content for section 1'}]\" /> @example <Accordion :options=\"accordionItems\" maxWidth=\"600px\" /> @example <Accordion :options=\"faqItems\" maxWidth=\"span 6\" /> /\nimport { ref, computed } from 'vue'\n\n/   Represents an accordion item with label and content @typedef {Object} AccordionItem @property {string} label - The label displayed in the accordion header @property {string} content - The content displayed when the accordion is expanded /\nexport interface AccordionItem {\n  /   The label displayed in the accordion header /\n  label: string;\n  \n  /   The content displayed when the accordion is expanded /\n  content: string;\n}\n\n/   Accordion component props @typedef {Object} AccordionProps /\nexport interface AccordionProps {\n  /   Array of accordion items to display @type {AccordionItem[]} @required /\n  options?: AccordionItem[];\n  \n  /   Maximum width of the accordion Can be a CSS value (e.g. '600px'), a number (interpreted as pixels), or a grid column span value (e.g. 'span 6') @type {string|number} /\n  maxWidth?: string | number;\n}\n\nconst props = withDefaults(defineProps<AccordionProps>(), {\n  options: () => [\n    {\n      label: 'Getting Started',\n      content: 'Welcome to our platform! This is a default accordion item that shows when no options are provided.'\n    },\n    {\n      label: 'Features',\n      content: 'Discover our amazing features and how they can help you achieve your goals.'\n    },\n    {\n      label: 'Support',\n      content: 'Need help? Our support team is here to assist you with any questions or concerns.'\n    }\n  ],\n  maxWidth: undefined\n})\n\n/   Computed styles for the accordion based on maxWidth prop Handles different formats of maxWidth (pixels, grid spans, etc.) /\nconst accordionStyles = computed(() => {\n  if (!props.maxWidth) return {}\n  \n  // If it's a number or ends with 'px', treat as pixel value\n  if (typeof props.maxWidth === 'number' || props.maxWidth.endsWith('px')) {\n    return { maxWidth: typeof props.maxWidth === 'number' ? `${props.maxWidth}px` : props.maxWidth }\n  }\n  \n  // If it's a span value (e.g. 'span 6')\n  if (props.maxWidth.startsWith('span')) {\n    return { gridColumn: props.maxWidth }\n  }\n  \n  return { maxWidth: props.maxWidth }\n})\n\n/   Indices of currently expanded accordion items /\nconst expandedIndices = ref<number[]>([])\n\n/   Index of the item currently being expanded (for animation) /\nconst isExpanding = ref<number | null>(null)\n\n/   Index of the item currently being collapsed (for animation) /\nconst isCollapsing = ref<number | null>(null)\n\n/   Start the expand animation for an accordion item @param {number} index - Index of the item being expanded /\nconst startExpand = (index: number) => {\n  isExpanding.value = index\n}\n\n/   End the expand animation /\nconst endExpand = () => {\n  isExpanding.value = null\n}\n\n/   Start the collapse animation for an accordion item @param {number} index - Index of the item being collapsed /\nconst startCollapse = (index: number) => {\n  isCollapsing.value = index\n}\n\n/   End the collapse animation /\nconst endCollapse = () => {\n  isCollapsing.value = null\n}\n\n/   Toggle expansion state of an accordion item @param {number} index - Index of the item to toggle",
        "params": [
          {
            "name": "index",
            "type": "number",
            "description": "Parameter index for the method",
            "required": true
          }
        ]
      }
    },
    "computed": {
      "accordionStyles": {
        "name": "accordionStyles",
        "type": "any",
        "description": "@component Accordion @description An expandable/collapsible accordion component that displays items with titles and expandable content. Features smooth animations and customizable max-width settings.  @example <Accordion :options=\"[{label: 'Section 1', content: 'This is the content for section 1'}]\" /> @example <Accordion :options=\"accordionItems\" maxWidth=\"600px\" /> @example <Accordion :options=\"faqItems\" maxWidth=\"span 6\" /> /\nimport { ref, computed } from 'vue'\n\n/   Represents an accordion item with label and content @typedef {Object} AccordionItem @property {string} label - The label displayed in the accordion header @property {string} content - The content displayed when the accordion is expanded /\nexport interface AccordionItem {\n  /   The label displayed in the accordion header /\n  label: string;\n  \n  /   The content displayed when the accordion is expanded /\n  content: string;\n}\n\n/   Accordion component props @typedef {Object} AccordionProps /\nexport interface AccordionProps {\n  /   Array of accordion items to display @type {AccordionItem[]} @required /\n  options?: AccordionItem[];\n  \n  /   Maximum width of the accordion Can be a CSS value (e.g. '600px'), a number (interpreted as pixels), or a grid column span value (e.g. 'span 6') @type {string|number} /\n  maxWidth?: string | number;\n}\n\nconst props = withDefaults(defineProps<AccordionProps>(), {\n  options: () => [\n    {\n      label: 'Getting Started',\n      content: 'Welcome to our platform! This is a default accordion item that shows when no options are provided.'\n    },\n    {\n      label: 'Features',\n      content: 'Discover our amazing features and how they can help you achieve your goals.'\n    },\n    {\n      label: 'Support',\n      content: 'Need help? Our support team is here to assist you with any questions or concerns.'\n    }\n  ],\n  maxWidth: undefined\n})\n\n/   Computed styles for the accordion based on maxWidth prop Handles different formats of maxWidth (pixels, grid spans, etc.)"
      }
    },
    "tokens": {
      "colors": [],
      "dimensions": [],
      "strings": []
    }
  },
  {
    "name": "GlimAvatar",
    "description": "@component GlimAvatar @description A versatile avatar component for displaying user images with fallback icon support. Supports different shapes (circle or squircle) and customizable sizing.  @example <GlimAvatar /> @example <GlimAvatar image=\"/path/to/image.jpg\" alt=\"User Name\" /> @example <GlimAvatar shape=\"squircle\" size={64} />",
    "props": {
      "image": {
        "name": "image",
        "type": "String",
        "required": false,
        "default": "https://cdn.cosmos.so/962784fe-d06b-4f23-84e5-f0a1efd3a6d6.?format=jpeg",
        "description": "The image prop"
      },
      "alt": {
        "name": "alt",
        "type": "String",
        "required": false,
        "default": "User avatar",
        "description": "The alt prop"
      },
      "size": {
        "name": "size",
        "type": "Number",
        "required": false,
        "default": "40",
        "description": "The size prop"
      },
      "shape": {
        "name": "shape",
        "type": "String",
        "required": false,
        "default": "circle",
        "description": "The shape prop"
      }
    },
    "events": {},
    "methods": {},
    "computed": {},
    "tokens": {
      "colors": [],
      "dimensions": [],
      "strings": []
    }
  },
  {
    "name": "GlimBadge",
    "description": "@component GlimBadge @description Displays a small numerical value or indicator that can be used for notifications, counts, or status indicators. The badge can be displayed as a number with optional maximum value or as a simple dot.  @example <GlimBadge value=\"5\" /> @example <GlimBadge value=\"100\" max=\"99\" /> @example <GlimBadge isDot /> @example <GlimBadge value=\"NEW\" />",
    "props": {
      "value": {
        "name": "value",
        "type": "any",
        "required": false,
        "default": "0",
        "description": "The value prop"
      },
      "max": {
        "name": "max",
        "type": "Number",
        "required": false,
        "default": "99",
        "description": "The max prop"
      },
      "isDot": {
        "name": "isDot",
        "type": "Boolean",
        "required": false,
        "default": "false",
        "description": "The isDot prop"
      }
    },
    "events": {},
    "methods": {
      "formattedContent": {
        "name": "formattedContent",
        "description": "@component GlimBadge @description Displays a small numerical value or indicator that can be used for notifications, counts, or status indicators. The badge can be displayed as a number with optional maximum value or as a simple dot.  @example <GlimBadge value=\"5\" /> @example <GlimBadge value=\"100\" max=\"99\" /> @example <GlimBadge isDot /> @example <GlimBadge value=\"NEW\" /> /\n\n/   Badge component props @typedef {Object} BadgeProps /\nconst props = defineProps({\n  /   Content to be displayed inside the badge @type {Number|String} @default 0 /\n  value: {\n    type: [Number, String],\n    default: 0\n  },\n  /   Maximum value to show before adding a '+' suffix If the value exceeds this number, it will display as \"{max}+\" @type {Number} @default 99 /\n  max: {\n    type: Number,\n    default: 99\n  },\n  /   Whether to display as a small dot without content When true, the badge appears as a simple colored dot indicator @type {Boolean} @default false /\n  isDot: {\n    type: Boolean,\n    default: false\n  }\n})\n\n/   Formats the badge content based on the max prop @returns {String|Number} Formatted value with '+' suffix if it exceeds the max",
        "params": [
          {
            "name": "(",
            "type": "any",
            "description": "Parameter ( for the method",
            "required": true
          }
        ]
      }
    },
    "computed": {
      "formattedContent": {
        "name": "formattedContent",
        "type": "any",
        "description": "@component GlimBadge @description Displays a small numerical value or indicator that can be used for notifications, counts, or status indicators. The badge can be displayed as a number with optional maximum value or as a simple dot.  @example <GlimBadge value=\"5\" /> @example <GlimBadge value=\"100\" max=\"99\" /> @example <GlimBadge isDot /> @example <GlimBadge value=\"NEW\" /> /\n\n/   Badge component props @typedef {Object} BadgeProps /\nconst props = defineProps({\n  /   Content to be displayed inside the badge @type {Number|String} @default 0 /\n  value: {\n    type: [Number, String],\n    default: 0\n  },\n  /   Maximum value to show before adding a '+' suffix If the value exceeds this number, it will display as \"{max}+\" @type {Number} @default 99 /\n  max: {\n    type: Number,\n    default: 99\n  },\n  /   Whether to display as a small dot without content When true, the badge appears as a simple colored dot indicator @type {Boolean} @default false /\n  isDot: {\n    type: Boolean,\n    default: false\n  }\n})\n\n/   Formats the badge content based on the max prop @returns {String|Number} Formatted value with '+' suffix if it exceeds the max"
      }
    },
    "tokens": {
      "colors": [],
      "dimensions": [],
      "strings": []
    }
  },
  {
    "name": "GlimBanner",
    "description": "@component GlimBanner @description A banner component that displays information or notifications with different variants. Can be dismissible and supports both a title and description.  @example <GlimBanner title=\"Notice\" /> @example <GlimBanner description=\"Important information\" variant=\"info\" /> @example <GlimBanner title=\"Dismissable Banner\" dismissable />",
    "props": {
      "description": {
        "name": "description",
        "type": "String",
        "required": false,
        "default": "Description",
        "description": "The description prop"
      },
      "title": {
        "name": "title",
        "type": "String",
        "required": false,
        "default": "Title",
        "description": "The title prop"
      },
      "variant": {
        "name": "variant",
        "type": "String",
        "required": false,
        "default": "default",
        "description": "The variant prop"
      },
      "dismissable": {
        "name": "dismissable",
        "type": "Boolean",
        "required": false,
        "default": "false",
        "description": "The dismissable prop"
      }
    },
    "events": {},
    "methods": {},
    "computed": {},
    "tokens": {
      "colors": [],
      "dimensions": [],
      "strings": []
    }
  },
  {
    "name": "GlimButton",
    "description": "@name GlimButton @description A versatile button component with multiple variants, sizes, and states. Supports icons, loading states, and inverse color schemes. Use for user interactions and form submissions.  @example <GlimButton>Click me</GlimButton> @example <GlimButton variant=\"secondary\" size=\"medium\">Secondary Button</GlimButton> @example <GlimButton prefixIcon=\"arrow-right\">With Icon</GlimButton> @example <GlimButton loading>Loading</GlimButton>  @displayName GlimButton @status stable @category Actions",
    "props": {
      "disabled": {
        "name": "disabled",
        "type": "Boolean",
        "required": false,
        "default": "false",
        "description": "The disabled prop"
      },
      "prefixIcon": {
        "name": "prefixIcon",
        "type": "String",
        "required": false,
        "description": "The prefixIcon prop"
      },
      "suffixIcon": {
        "name": "suffixIcon",
        "type": "String",
        "required": false,
        "description": "The suffixIcon prop"
      },
      "size": {
        "name": "size",
        "type": "String",
        "required": false,
        "default": "medium",
        "description": "The size prop"
      },
      "loading": {
        "name": "loading",
        "type": "Boolean",
        "required": false,
        "default": "false",
        "description": "The loading prop"
      },
      "primary": {
        "name": "primary",
        "type": "Main",
        "description": "The primary prop"
      },
      "secondary": {
        "name": "secondary",
        "type": "Alternative",
        "description": "The secondary prop"
      },
      "ghost": {
        "name": "ghost",
        "type": "Subtle",
        "description": "The ghost prop"
      },
      "danger": {
        "name": "danger",
        "type": "Destructive",
        "description": "The danger prop"
      },
      "variant": {
        "name": "variant",
        "type": "String",
        "required": false,
        "default": "primary",
        "description": "The variant prop"
      },
      "inverse": {
        "name": "inverse",
        "type": "Boolean",
        "required": false,
        "default": "false",
        "description": "The inverse prop"
      },
      "type": {
        "name": "type",
        "type": "String",
        "required": false,
        "default": "button",
        "description": "The type prop"
      },
      "name": {
        "name": "name",
        "type": "String",
        "required": false,
        "description": "The name prop"
      }
    },
    "events": {},
    "methods": {
      "handleClick": {
        "name": "handleClick",
        "description": "@name GlimButton @description A versatile button component with multiple variants, sizes, and states. Supports icons, loading states, and inverse color schemes. Use for user interactions and form submissions.  @example <GlimButton>Click me</GlimButton> @example <GlimButton variant=\"secondary\" size=\"medium\">Secondary Button</GlimButton> @example <GlimButton prefixIcon=\"arrow-right\">With Icon</GlimButton> @example <GlimButton loading>Loading</GlimButton>  @displayName GlimButton @status stable @category Actions /\n\nconst props = defineProps({\n  /   Whether the button is disabled @type {boolean} @default false /\n  disabled: {\n    type: Boolean,\n    default: false\n  },\n\n  /   Icon to display before the button content Uses Feather icon names @type {string} @default '' /\n  prefixIcon: {\n    type: String,\n    default: ''\n  },\n\n  /   Icon to display after the button content Uses Feather icon names @type {string} @default '' /\n  suffixIcon: {\n    type: String,\n    default: ''\n  },\n\n  /   Size of the button Controls padding, font size, and overall dimensions @type {'large'|'medium'|'small'} @default 'medium' @values large, medium, small /\n  size: {\n    type: String as () => 'large' | 'medium' | 'small',\n    default: 'medium',\n    validator: (value: string) => ['large', 'medium', 'small'].includes(value)\n  },\n\n  /   Whether the button is in loading state When true, displays a spinner and disables interactions @type {boolean} @default false /\n  loading: {\n    type: Boolean,\n    default: false\n  },\n\n  /   Visual style variant of the button - primary: Main call-to-action - secondary: Alternative or less prominent action - ghost: Subtle or auxiliary action - danger: Destructive or warning action @type {'primary'|'secondary'|'ghost'|'danger'} @default 'primary' @values primary, secondary, ghost, danger /\n  variant: {\n    type: String as () => 'primary' | 'secondary' | 'ghost' | 'danger',\n    default: 'primary',\n    validator: (value: string) => ['primary', 'secondary', 'ghost', 'danger'].includes(value)\n  },\n\n  /   Whether to use inverse color scheme Useful for buttons on dark backgrounds @type {boolean} @default false /\n  inverse: {\n    type: Boolean,\n    default: false\n  },\n  \n  /   Button type attribute (button, submit, reset) @type {'button'|'submit'|'reset'} @default 'button' @values button, submit, reset /\n  type: {\n    type: String as () => 'button' | 'submit' | 'reset',\n    default: 'button',\n    validator: (value: string) => ['button', 'submit', 'reset'].includes(value)\n  },\n  \n  /   Name attribute for the button @type {string} @default '' /\n  name: {\n    type: String,\n    default: ''\n  }\n})\n\n/   Icon sizes mapped to button sizes @private /\nconst ICON_SIZE_MAP = {\n  large: 20,\n  medium: 16,\n  small: 12\n} as const\n\n/   Computes the icon size based on button size @private /\nconst iconSize = computed<number>(() => {\n  return ICON_SIZE_MAP[props.size as keyof typeof ICON_SIZE_MAP] || 16\n})\n\n/   Define emitted events /\nconst emit = defineEmits<{\n  /   Emitted when the button is clicked and not disabled or loading @event click /\n  'click': []\n}>()\n\n/   Handle button click event @private"
      },
      "iconSize": {
        "name": "iconSize",
        "description": "@name GlimButton @description A versatile button component with multiple variants, sizes, and states. Supports icons, loading states, and inverse color schemes. Use for user interactions and form submissions.  @example <GlimButton>Click me</GlimButton> @example <GlimButton variant=\"secondary\" size=\"medium\">Secondary Button</GlimButton> @example <GlimButton prefixIcon=\"arrow-right\">With Icon</GlimButton> @example <GlimButton loading>Loading</GlimButton>  @displayName GlimButton @status stable @category Actions /\n\nconst props = defineProps({\n  /   Whether the button is disabled @type {boolean} @default false /\n  disabled: {\n    type: Boolean,\n    default: false\n  },\n\n  /   Icon to display before the button content Uses Feather icon names @type {string} @default '' /\n  prefixIcon: {\n    type: String,\n    default: ''\n  },\n\n  /   Icon to display after the button content Uses Feather icon names @type {string} @default '' /\n  suffixIcon: {\n    type: String,\n    default: ''\n  },\n\n  /   Size of the button Controls padding, font size, and overall dimensions @type {'large'|'medium'|'small'} @default 'medium' @values large, medium, small /\n  size: {\n    type: String as () => 'large' | 'medium' | 'small',\n    default: 'medium',\n    validator: (value: string) => ['large', 'medium', 'small'].includes(value)\n  },\n\n  /   Whether the button is in loading state When true, displays a spinner and disables interactions @type {boolean} @default false /\n  loading: {\n    type: Boolean,\n    default: false\n  },\n\n  /   Visual style variant of the button - primary: Main call-to-action - secondary: Alternative or less prominent action - ghost: Subtle or auxiliary action - danger: Destructive or warning action @type {'primary'|'secondary'|'ghost'|'danger'} @default 'primary' @values primary, secondary, ghost, danger /\n  variant: {\n    type: String as () => 'primary' | 'secondary' | 'ghost' | 'danger',\n    default: 'primary',\n    validator: (value: string) => ['primary', 'secondary', 'ghost', 'danger'].includes(value)\n  },\n\n  /   Whether to use inverse color scheme Useful for buttons on dark backgrounds @type {boolean} @default false /\n  inverse: {\n    type: Boolean,\n    default: false\n  },\n  \n  /   Button type attribute (button, submit, reset) @type {'button'|'submit'|'reset'} @default 'button' @values button, submit, reset /\n  type: {\n    type: String as () => 'button' | 'submit' | 'reset',\n    default: 'button',\n    validator: (value: string) => ['button', 'submit', 'reset'].includes(value)\n  },\n  \n  /   Name attribute for the button @type {string} @default '' /\n  name: {\n    type: String,\n    default: ''\n  }\n})\n\n/   Icon sizes mapped to button sizes @private /\nconst ICON_SIZE_MAP = {\n  large: 20,\n  medium: 16,\n  small: 12\n} as const\n\n/   Computes the icon size based on button size @private",
        "params": [
          {
            "name": "(",
            "type": "any",
            "description": "Parameter ( for the method",
            "required": true
          }
        ]
      }
    },
    "computed": {},
    "tokens": {
      "colors": [],
      "dimensions": [],
      "strings": []
    }
  },
  {
    "name": "GlimCard",
    "description": "@name GlimCard @description A versatile card component for displaying content with optional image and action slots. Cards can be used for various purposes such as product cards, article previews, or feature highlights.  @displayName Card @status stable @category Data Display  @example <GlimCard title=\"Card Title\" text=\"Card description text\" /> @example <GlimCard title=\"Product Name\" text=\"Product description\" imageSrc=\"/images/product.jpg\" /> @example <GlimCard title=\"Spanning Card\" width=\"span 2\"> <template #actions> <GlimButton>Action</GlimButton> </template> </GlimCard>",
    "props": {},
    "events": {},
    "methods": {
      "cardStyle": {
        "name": "cardStyle",
        "description": "@name GlimCard @description A versatile card component for displaying content with optional image and action slots. Cards can be used for various purposes such as product cards, article previews, or feature highlights.  @displayName Card @status stable @category Data Display  @example <GlimCard title=\"Card Title\" text=\"Card description text\" /> @example <GlimCard title=\"Product Name\" text=\"Product description\" imageSrc=\"/images/product.jpg\" /> @example <GlimCard title=\"Spanning Card\" width=\"span 2\"> <template #actions> <GlimButton>Action</GlimButton> </template> </GlimCard> /\n\n/   Valid values for width prop @typedef {number|`${number}`|`span ${number}`|'auto'} WidthValue /\ntype WidthValue = number | `${number}` | `span ${number}` | 'auto'\n\n/   Card component props @typedef {Object} CardProps /\ninterface Props {\n  /   Text displayed above the title (optional header text) @type {string} /\n  headerText?: string\n  \n  /   Main title of the card @type {string} /\n  title?: string\n  \n  /   Description or content text @type {string} /\n  text?: string\n  \n  /   URL or path to the card's image @type {string} /\n  imageSrc?: string\n  \n  /   Alt text for the image (for accessibility) @type {string} /\n  imageAlt?: string\n  \n  /   Aspect ratio of the image @type {'1x1'|'16x9'|'4x3'|'4x5'|'3x2'|'5x4'} /\n  imageAspectRatio?: '1x1' | '16x9' | '4x3' | '4x5' | '3x2' | '5x4'\n  \n  /   Orientation of the image @type {'landscape'|'portrait'} /\n  imageOrientation?: 'landscape' | 'portrait'\n  \n  /   URL when the card is clickable @type {string} /\n  href?: string\n  \n  /   Width of the card - can be pixels, a CSS value, or a grid span @type {WidthValue} /\n  width?: WidthValue\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  headerText: '',\n  title: 'Title',\n  text: 'Text',\n  imageSrc: 'https://cdn.cosmos.so/962784fe-d06b-4f23-84e5-f0a1efd3a6d6.?format=jpeg',\n  imageAlt: 'Image Alt',\n  imageAspectRatio: '4x3',\n  imageOrientation: 'landscape',\n  href: '',\n  width: 'auto'\n})\n\n/   Computed CSS styles for the card based on the width prop @returns {Object} CSS style object",
        "params": [
          {
            "name": "(",
            "type": "any",
            "description": "Parameter ( for the method",
            "required": true
          }
        ]
      }
    },
    "computed": {
      "cardStyle": {
        "name": "cardStyle",
        "type": "any",
        "description": "@name GlimCard @description A versatile card component for displaying content with optional image and action slots. Cards can be used for various purposes such as product cards, article previews, or feature highlights.  @displayName Card @status stable @category Data Display  @example <GlimCard title=\"Card Title\" text=\"Card description text\" /> @example <GlimCard title=\"Product Name\" text=\"Product description\" imageSrc=\"/images/product.jpg\" /> @example <GlimCard title=\"Spanning Card\" width=\"span 2\"> <template #actions> <GlimButton>Action</GlimButton> </template> </GlimCard> /\n\n/   Valid values for width prop @typedef {number|`${number}`|`span ${number}`|'auto'} WidthValue /\ntype WidthValue = number | `${number}` | `span ${number}` | 'auto'\n\n/   Card component props @typedef {Object} CardProps /\ninterface Props {\n  /   Text displayed above the title (optional header text) @type {string} /\n  headerText?: string\n  \n  /   Main title of the card @type {string} /\n  title?: string\n  \n  /   Description or content text @type {string} /\n  text?: string\n  \n  /   URL or path to the card's image @type {string} /\n  imageSrc?: string\n  \n  /   Alt text for the image (for accessibility) @type {string} /\n  imageAlt?: string\n  \n  /   Aspect ratio of the image @type {'1x1'|'16x9'|'4x3'|'4x5'|'3x2'|'5x4'} /\n  imageAspectRatio?: '1x1' | '16x9' | '4x3' | '4x5' | '3x2' | '5x4'\n  \n  /   Orientation of the image @type {'landscape'|'portrait'} /\n  imageOrientation?: 'landscape' | 'portrait'\n  \n  /   URL when the card is clickable @type {string} /\n  href?: string\n  \n  /   Width of the card - can be pixels, a CSS value, or a grid span @type {WidthValue} /\n  width?: WidthValue\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  headerText: '',\n  title: 'Title',\n  text: 'Text',\n  imageSrc: 'https://cdn.cosmos.so/962784fe-d06b-4f23-84e5-f0a1efd3a6d6.?format=jpeg',\n  imageAlt: 'Image Alt',\n  imageAspectRatio: '4x3',\n  imageOrientation: 'landscape',\n  href: '',\n  width: 'auto'\n})\n\n/   Computed CSS styles for the card based on the width prop @returns {Object} CSS style object"
      }
    },
    "tokens": {
      "colors": [],
      "dimensions": [],
      "strings": []
    }
  },
  {
    "name": "GlimCheckbox",
    "description": "@component GlimCheckbox @description A checkbox component for boolean inputs with customizable label and sizing. Follows accessibility best practices and provides visual feedback for different states.  @example <GlimCheckbox v-model=\"isChecked\" /> @example <GlimCheckbox v-model=\"agreeToTerms\" label=\"I agree to the terms and conditions\" /> @example <GlimCheckbox v-model=\"rememberMe\" size=\"small\" label=\"Remember me\" /> @example <GlimCheckbox v-model=\"isDisabled\" disabled /> @example <GlimCheckbox v-model=\"value\" error=\"This field is required\" /> @example <GlimCheckbox v-model=\"value\" success=\"Valid selection\" /> @example <GlimCheckbox v-model=\"value\" indeterminate />",
    "props": {},
    "events": {},
    "methods": {
      "toggle": {
        "name": "toggle",
        "description": "Method toggle"
      }
    },
    "computed": {},
    "tokens": {
      "colors": [],
      "dimensions": [],
      "strings": []
    }
  },
  {
    "name": "GlimDivider",
    "description": "@name GlimDivider @description A versatile divider component for visual separation of content. Supports both horizontal and vertical orientations with various color strengths. @example <GlimDivider /> <GlimDivider orientation=\"vertical\" color=\"strong\" margin=\"16\" />",
    "props": {},
    "events": {},
    "methods": {
      "marginStyle": {
        "name": "marginStyle",
        "description": "Method marginStyle",
        "params": [
          {
            "name": "(",
            "type": "any",
            "description": "Parameter ( for the method",
            "required": true
          }
        ]
      }
    },
    "computed": {
      "marginStyle": {
        "name": "marginStyle",
        "type": "any",
        "description": "Computed property marginStyle"
      }
    },
    "tokens": {
      "colors": [],
      "dimensions": [],
      "strings": []
    }
  },
  {
    "name": "GlimDropdown",
    "description": "GlimDropdown provides a dropdown selection interface with optional editable input field  @displayName GlimDropdown @status stable @group Form Controls  @example Basic Usage ```vue <GlimDropdown id=\"dropdown1\" v-model=\"selectedOption\" :items=\"[{label: 'Option 1'}, {label: 'Option 2'}]\" label=\"Select an option\" /> ```  @example Editable Dropdown ```vue <GlimDropdown id=\"editableDropdown\" v-model=\"selectedOption\" :items=\"dropdownOptions\" label=\"Select or type\" :editable=\"true\" /> ```",
    "props": {},
    "events": {},
    "methods": {
      "displayValue": {
        "name": "displayValue",
        "description": "Method displayValue",
        "params": [
          {
            "name": "(",
            "type": "any",
            "description": "Parameter ( for the method",
            "required": true
          }
        ]
      },
      "processedOptions": {
        "name": "processedOptions",
        "description": "Method processedOptions",
        "params": [
          {
            "name": "(",
            "type": "any",
            "description": "Parameter ( for the method",
            "required": true
          }
        ]
      },
      "toggleDropdown": {
        "name": "toggleDropdown",
        "description": "Method toggleDropdown"
      },
      "handleInputChange": {
        "name": "handleInputChange",
        "description": "Method handleInputChange",
        "params": [
          {
            "name": "value",
            "type": "string",
            "description": "Parameter value for the method",
            "required": true
          }
        ]
      },
      "handleItemClick": {
        "name": "handleItemClick",
        "description": "Method handleItemClick",
        "params": [
          {
            "name": "item",
            "type": "DropdownItem",
            "description": "Parameter item for the method",
            "required": true
          }
        ]
      },
      "handleClickOutside": {
        "name": "handleClickOutside",
        "description": "Method handleClickOutside",
        "params": [
          {
            "name": "event",
            "type": "MouseEvent",
            "description": "Parameter event for the method",
            "required": true
          }
        ]
      }
    },
    "computed": {
      "displayValue": {
        "name": "displayValue",
        "type": "any",
        "description": "Computed property displayValue"
      },
      "processedOptions": {
        "name": "processedOptions",
        "type": "any",
        "description": "Computed property processedOptions"
      }
    },
    "tokens": {
      "colors": [],
      "dimensions": [],
      "strings": []
    }
  },
  {
    "name": "GlimIcon",
    "description": "@component GlimIcon @description Renders SVG icons from the Feather icon library with customizable size and color. This component provides a simple way to include consistent icons throughout the application.  @example <GlimIcon name=\"user\" /> @example <GlimIcon name=\"heart\" size=\"16\" color=\"red\" /> @example <GlimIcon name=\"star\" size=\"32\" /> @see {@link https://feathericons.com/|Feather Icons} for available icon names",
    "props": {},
    "events": {},
    "methods": {
      "colorValue": {
        "name": "colorValue",
        "description": "@component GlimIcon @description Renders SVG icons from the Feather icon library with customizable size and color. This component provides a simple way to include consistent icons throughout the application.  @example <GlimIcon name=\"user\" /> @example <GlimIcon name=\"heart\" size=\"16\" color=\"red\" /> @example <GlimIcon name=\"star\" size=\"32\" /> @see {@link https://feathericons.com/|Feather Icons} for available icon names /\n\n/   Icon component props /\nexport interface GlimIconProps {\n  /   Name of the icon from Feather icon set @type {string} @required @see {@link https://feathericons.com/|Available Icons} /\n  name: string\n  \n  /   Size of the icon in pixels @type {number} @default 24 /\n  size?: number\n  \n  /   Color variant of the icon @type {'currentColor' | 'strong' | 'defined' | 'soft' | 'disabled' | 'discrete'} @default 'currentColor' /\n  color?: 'currentColor' | 'strong' | 'defined' | 'soft' | 'disabled' | 'discrete'\n}\n\nconst props = withDefaults(defineProps<GlimIconProps>(), {\n  size: 24,\n  color: 'currentColor'\n})\n\n/   Computed color value based on the color variant @returns {string} CSS color value",
        "params": [
          {
            "name": "(",
            "type": "any",
            "description": "Parameter ( for the method",
            "required": true
          }
        ]
      },
      "svgContent": {
        "name": "svgContent",
        "description": "@component GlimIcon @description Renders SVG icons from the Feather icon library with customizable size and color. This component provides a simple way to include consistent icons throughout the application.  @example <GlimIcon name=\"user\" /> @example <GlimIcon name=\"heart\" size=\"16\" color=\"red\" /> @example <GlimIcon name=\"star\" size=\"32\" /> @see {@link https://feathericons.com/|Feather Icons} for available icon names /\n\n/   Icon component props /\nexport interface GlimIconProps {\n  /   Name of the icon from Feather icon set @type {string} @required @see {@link https://feathericons.com/|Available Icons} /\n  name: string\n  \n  /   Size of the icon in pixels @type {number} @default 24 /\n  size?: number\n  \n  /   Color variant of the icon @type {'currentColor' | 'strong' | 'defined' | 'soft' | 'disabled' | 'discrete'} @default 'currentColor' /\n  color?: 'currentColor' | 'strong' | 'defined' | 'soft' | 'disabled' | 'discrete'\n}\n\nconst props = withDefaults(defineProps<GlimIconProps>(), {\n  size: 24,\n  color: 'currentColor'\n})\n\n/   Computed color value based on the color variant @returns {string} CSS color value /\nconst colorValue = computed(() => {\n  switch (props.color) {\n    case 'strong':\n      return 'var(--glim-color-text-strong)'\n    case 'defined':\n      return 'var(--glim-color-text-defined)'\n    case 'soft':\n      return 'var(--glim-color-text-soft)'\n    case 'disabled':\n      return 'var(--glim-color-text-disabled)'\n    case 'discrete':\n      return 'var(--glim-color-text-discrete)'\n    default:\n      return 'currentColor'\n  }\n})\n\n/   Computed SVG content based on the icon name @returns {string} Raw SVG HTML string or empty string if icon not found",
        "params": [
          {
            "name": "(",
            "type": "any",
            "description": "Parameter ( for the method",
            "required": true
          }
        ]
      }
    },
    "computed": {
      "colorValue": {
        "name": "colorValue",
        "type": "any",
        "description": "@component GlimIcon @description Renders SVG icons from the Feather icon library with customizable size and color. This component provides a simple way to include consistent icons throughout the application.  @example <GlimIcon name=\"user\" /> @example <GlimIcon name=\"heart\" size=\"16\" color=\"red\" /> @example <GlimIcon name=\"star\" size=\"32\" /> @see {@link https://feathericons.com/|Feather Icons} for available icon names /\n\n/   Icon component props /\nexport interface GlimIconProps {\n  /   Name of the icon from Feather icon set @type {string} @required @see {@link https://feathericons.com/|Available Icons} /\n  name: string\n  \n  /   Size of the icon in pixels @type {number} @default 24 /\n  size?: number\n  \n  /   Color variant of the icon @type {'currentColor' | 'strong' | 'defined' | 'soft' | 'disabled' | 'discrete'} @default 'currentColor' /\n  color?: 'currentColor' | 'strong' | 'defined' | 'soft' | 'disabled' | 'discrete'\n}\n\nconst props = withDefaults(defineProps<GlimIconProps>(), {\n  size: 24,\n  color: 'currentColor'\n})\n\n/   Computed color value based on the color variant @returns {string} CSS color value"
      },
      "svgContent": {
        "name": "svgContent",
        "type": "any",
        "description": "@component GlimIcon @description Renders SVG icons from the Feather icon library with customizable size and color. This component provides a simple way to include consistent icons throughout the application.  @example <GlimIcon name=\"user\" /> @example <GlimIcon name=\"heart\" size=\"16\" color=\"red\" /> @example <GlimIcon name=\"star\" size=\"32\" /> @see {@link https://feathericons.com/|Feather Icons} for available icon names /\n\n/   Icon component props /\nexport interface GlimIconProps {\n  /   Name of the icon from Feather icon set @type {string} @required @see {@link https://feathericons.com/|Available Icons} /\n  name: string\n  \n  /   Size of the icon in pixels @type {number} @default 24 /\n  size?: number\n  \n  /   Color variant of the icon @type {'currentColor' | 'strong' | 'defined' | 'soft' | 'disabled' | 'discrete'} @default 'currentColor' /\n  color?: 'currentColor' | 'strong' | 'defined' | 'soft' | 'disabled' | 'discrete'\n}\n\nconst props = withDefaults(defineProps<GlimIconProps>(), {\n  size: 24,\n  color: 'currentColor'\n})\n\n/   Computed color value based on the color variant @returns {string} CSS color value /\nconst colorValue = computed(() => {\n  switch (props.color) {\n    case 'strong':\n      return 'var(--glim-color-text-strong)'\n    case 'defined':\n      return 'var(--glim-color-text-defined)'\n    case 'soft':\n      return 'var(--glim-color-text-soft)'\n    case 'disabled':\n      return 'var(--glim-color-text-disabled)'\n    case 'discrete':\n      return 'var(--glim-color-text-discrete)'\n    default:\n      return 'currentColor'\n  }\n})\n\n/   Computed SVG content based on the icon name @returns {string} Raw SVG HTML string or empty string if icon not found"
      }
    },
    "tokens": {
      "colors": [],
      "dimensions": [],
      "strings": []
    }
  },
  {
    "name": "GlimImage",
    "description": "@component GlimImage @description A responsive image component that maintains aspect ratio and supports various image formats. Handles different aspect ratios and orientations, and provides a placeholder when no image is available.  @example <GlimImage src=\"/images/photo.jpg\" alt=\"A beautiful landscape\" /> @example <GlimImage src=\"/images/portrait.jpg\" aspectRatio=\"4x5\" orientation=\"portrait\" /> @example <GlimImage backgroundColor=\"#f0f0f0\" aspectRatio=\"1x1\" />",
    "props": {},
    "events": {},
    "methods": {},
    "computed": {
      "isPortrait": {
        "name": "isPortrait",
        "type": "any",
        "description": "@component GlimImage @description A responsive image component that maintains aspect ratio and supports various image formats. Handles different aspect ratios and orientations, and provides a placeholder when no image is available.  @example <GlimImage src=\"/images/photo.jpg\" alt=\"A beautiful landscape\" /> @example <GlimImage src=\"/images/portrait.jpg\" aspectRatio=\"4x5\" orientation=\"portrait\" /> @example <GlimImage backgroundColor=\"#f0f0f0\" aspectRatio=\"1x1\" /> /\n\n/   Valid aspect ratio options @typedef {'1x1'|'16x9'|'4x3'|'4x5'|'3x2'|'5x4'} AspectRatio /\ntype AspectRatio = '1x1' | '16x9' | '4x3' | '4x5' | '3x2' | '5x4'\n\n/   Image orientation options @typedef {'landscape'|'portrait'} Orientation /\ntype Orientation = 'landscape' | 'portrait'\n\n/   Image component props @typedef {Object} GlimImageProps /\ninterface Props {\n  /   Source URL for the image @type {string} @default 'https://cdn.cosmos.so/962784fe-d06b-4f23-84e5-f0a1efd3a6d6.?format=jpeg' /\n  src?: string\n  \n  /   Alt text for accessibility @type {string} @default 'Image Alt' /\n  alt?: string\n  \n  /   Aspect ratio of the image container @type {AspectRatio} @default '16x9' /\n  aspectRatio?: AspectRatio\n  \n  /   Orientation of the image @type {Orientation} @default 'landscape' /\n  orientation?: Orientation\n  \n  /   Background color when no image is provided Can be any valid CSS color value @type {string} @default 'transparent' /\n  backgroundColor?: string\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  src: 'https://cdn.cosmos.so/962784fe-d06b-4f23-84e5-f0a1efd3a6d6.?format=jpeg',\n  alt: 'Image Alt',\n  aspectRatio: '16x9',\n  orientation: 'landscape',\n  backgroundColor: 'transparent'\n})\n\n/   Computed property to determine if the image should be displayed in portrait mode @returns {boolean} True if orientation is 'portrait'"
      }
    },
    "tokens": {
      "colors": [],
      "dimensions": [],
      "strings": []
    }
  },
  {
    "name": "GlimInput",
    "description": "@name GlimInput @component @description A form input component with support for various states, icons, and validation. Provides a consistent interface for text input with built-in error handling and visual feedback.  @example <GlimInput v-model=\"modelValue\" label=\"Username\" placeholder=\"Enter username\" /> @example <GlimInput v-model=\"email\" type=\"email\" prefixIcon=\"mail\" error=\"Invalid email format\" /> @example <GlimInput v-model=\"search\" suffixIcon=\"search\" showClearButton />",
    "props": {},
    "events": {
      "focus": {
        "name": "focus",
        "description": "Emitted when focus occurs"
      },
      "blur": {
        "name": "blur",
        "description": "Emitted when blur occurs"
      }
    },
    "methods": {
      "clearInput": {
        "name": "clearInput",
        "description": "@name GlimInput @component @description A form input component with support for various states, icons, and validation. Provides a consistent interface for text input with built-in error handling and visual feedback.  @example <GlimInput v-model=\"modelValue\" label=\"Username\" placeholder=\"Enter username\" /> @example <GlimInput v-model=\"email\" type=\"email\" prefixIcon=\"mail\" error=\"Invalid email format\" /> @example <GlimInput v-model=\"search\" suffixIcon=\"search\" showClearButton /> /\n\n/   Input component props @typedef {Object} InputProps /\ninterface Props {\n  /   Current value of the input (v-model) @type {string} @required /\n  modelValue: string\n  \n  /   Label text displayed above the input @type {string} @default 'Label' /\n  label?: string\n  \n  /   Placeholder text displayed when input is empty @type {string} @default 'Placeholder' /\n  placeholder?: string\n  \n  /   HTML input type (text, password, email, etc.) @type {string} @default 'text' /\n  type?: string\n  \n  /   Size variant of the input @type {'large'|'medium'|'small'} @default 'medium' /\n  size?: 'large' | 'medium' | 'small'\n  \n  /   Whether the input is disabled @type {boolean} @default false /\n  disabled?: boolean\n  \n  /   Whether the input is read-only @type {boolean} @default false /\n  readonly?: boolean\n  \n  /   Error message to display below the input @type {string} @default '' /\n  error?: string\n  \n  /   Success message to display below the input @type {string} @default '' /\n  success?: string\n  \n  /   Icon to display at the start of the input @type {string} @default '' /\n  prefixIcon?: string\n  \n  /   Icon to display at the end of the input @type {string} @default '' /\n  suffixIcon?: string\n  \n  /   Unique identifier for the input element Used for accessibility (connecting label and error messages) @type {string} @required /\n  id: string\n  \n  /   Whether to show a clear button when the input has a value @type {boolean} @default false /\n  showClearButton?: boolean\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  label: 'Label',\n  placeholder: 'Placeholder',\n  type: 'text',\n  size: 'medium',\n  disabled: false,\n  readonly: false,\n  error: '',\n  success: '',\n  prefixIcon: '',\n  suffixIcon: '',\n  showClearButton: false\n})\n\n/   Events emitted by the Input component @event update:modelValue - Emitted when the input value changes @event focus - Emitted when the input receives focus @event blur - Emitted when the input loses focus /\nconst emit = defineEmits(['update:modelValue', 'focus', 'blur'])\n\n\n/   Local computed value for v-model binding @private /\nconst localValue = computed({\n  get: () => props.modelValue,\n  set: (value: string) => emit('update:modelValue', value)\n})\n\n/   Clears the input value"
      },
      "iconSize": {
        "name": "iconSize",
        "description": "@name GlimInput @component @description A form input component with support for various states, icons, and validation. Provides a consistent interface for text input with built-in error handling and visual feedback.  @example <GlimInput v-model=\"modelValue\" label=\"Username\" placeholder=\"Enter username\" /> @example <GlimInput v-model=\"email\" type=\"email\" prefixIcon=\"mail\" error=\"Invalid email format\" /> @example <GlimInput v-model=\"search\" suffixIcon=\"search\" showClearButton /> /\n\n/   Input component props @typedef {Object} InputProps /\ninterface Props {\n  /   Current value of the input (v-model) @type {string} @required /\n  modelValue: string\n  \n  /   Label text displayed above the input @type {string} @default 'Label' /\n  label?: string\n  \n  /   Placeholder text displayed when input is empty @type {string} @default 'Placeholder' /\n  placeholder?: string\n  \n  /   HTML input type (text, password, email, etc.) @type {string} @default 'text' /\n  type?: string\n  \n  /   Size variant of the input @type {'large'|'medium'|'small'} @default 'medium' /\n  size?: 'large' | 'medium' | 'small'\n  \n  /   Whether the input is disabled @type {boolean} @default false /\n  disabled?: boolean\n  \n  /   Whether the input is read-only @type {boolean} @default false /\n  readonly?: boolean\n  \n  /   Error message to display below the input @type {string} @default '' /\n  error?: string\n  \n  /   Success message to display below the input @type {string} @default '' /\n  success?: string\n  \n  /   Icon to display at the start of the input @type {string} @default '' /\n  prefixIcon?: string\n  \n  /   Icon to display at the end of the input @type {string} @default '' /\n  suffixIcon?: string\n  \n  /   Unique identifier for the input element Used for accessibility (connecting label and error messages) @type {string} @required /\n  id: string\n  \n  /   Whether to show a clear button when the input has a value @type {boolean} @default false /\n  showClearButton?: boolean\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  label: 'Label',\n  placeholder: 'Placeholder',\n  type: 'text',\n  size: 'medium',\n  disabled: false,\n  readonly: false,\n  error: '',\n  success: '',\n  prefixIcon: '',\n  suffixIcon: '',\n  showClearButton: false\n})\n\n/   Events emitted by the Input component @event update:modelValue - Emitted when the input value changes @event focus - Emitted when the input receives focus @event blur - Emitted when the input loses focus /\nconst emit = defineEmits(['update:modelValue', 'focus', 'blur'])\n\n\n/   Local computed value for v-model binding @private /\nconst localValue = computed({\n  get: () => props.modelValue,\n  set: (value: string) => emit('update:modelValue', value)\n})\n\n/   Clears the input value /\nconst clearInput = () => {\n  emit('update:modelValue', '')\n}\n\n/   Computed property for icon size based on input size @returns {number} Size of icon in pixels",
        "params": [
          {
            "name": "(",
            "type": "any",
            "description": "Parameter ( for the method",
            "required": true
          }
        ]
      }
    },
    "computed": {
      "iconSize": {
        "name": "iconSize",
        "type": "any",
        "description": "@name GlimInput @component @description A form input component with support for various states, icons, and validation. Provides a consistent interface for text input with built-in error handling and visual feedback.  @example <GlimInput v-model=\"modelValue\" label=\"Username\" placeholder=\"Enter username\" /> @example <GlimInput v-model=\"email\" type=\"email\" prefixIcon=\"mail\" error=\"Invalid email format\" /> @example <GlimInput v-model=\"search\" suffixIcon=\"search\" showClearButton /> /\n\n/   Input component props @typedef {Object} InputProps /\ninterface Props {\n  /   Current value of the input (v-model) @type {string} @required /\n  modelValue: string\n  \n  /   Label text displayed above the input @type {string} @default 'Label' /\n  label?: string\n  \n  /   Placeholder text displayed when input is empty @type {string} @default 'Placeholder' /\n  placeholder?: string\n  \n  /   HTML input type (text, password, email, etc.) @type {string} @default 'text' /\n  type?: string\n  \n  /   Size variant of the input @type {'large'|'medium'|'small'} @default 'medium' /\n  size?: 'large' | 'medium' | 'small'\n  \n  /   Whether the input is disabled @type {boolean} @default false /\n  disabled?: boolean\n  \n  /   Whether the input is read-only @type {boolean} @default false /\n  readonly?: boolean\n  \n  /   Error message to display below the input @type {string} @default '' /\n  error?: string\n  \n  /   Success message to display below the input @type {string} @default '' /\n  success?: string\n  \n  /   Icon to display at the start of the input @type {string} @default '' /\n  prefixIcon?: string\n  \n  /   Icon to display at the end of the input @type {string} @default '' /\n  suffixIcon?: string\n  \n  /   Unique identifier for the input element Used for accessibility (connecting label and error messages) @type {string} @required /\n  id: string\n  \n  /   Whether to show a clear button when the input has a value @type {boolean} @default false /\n  showClearButton?: boolean\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  label: 'Label',\n  placeholder: 'Placeholder',\n  type: 'text',\n  size: 'medium',\n  disabled: false,\n  readonly: false,\n  error: '',\n  success: '',\n  prefixIcon: '',\n  suffixIcon: '',\n  showClearButton: false\n})\n\n/   Events emitted by the Input component @event update:modelValue - Emitted when the input value changes @event focus - Emitted when the input receives focus @event blur - Emitted when the input loses focus /\nconst emit = defineEmits(['update:modelValue', 'focus', 'blur'])\n\n\n/   Local computed value for v-model binding @private /\nconst localValue = computed({\n  get: () => props.modelValue,\n  set: (value: string) => emit('update:modelValue', value)\n})\n\n/   Clears the input value /\nconst clearInput = () => {\n  emit('update:modelValue', '')\n}\n\n/   Computed property for icon size based on input size @returns {number} Size of icon in pixels"
      }
    },
    "tokens": {
      "colors": [],
      "dimensions": [],
      "strings": []
    }
  },
  {
    "name": "GlimMenu",
    "description": "@component GlimMenu @description A menu component that displays a list of selectable items. Used for dropdown menus, context menus, and other selection interfaces.  @example <GlimMenu :items=\"[{label: 'Option 1'}, {label: 'Option 2', selected: true}]\" @click=\"handleItemClick\" /> @example <GlimMenu :items=\"menuOptions\" @click=\"(item) => selectedItem = item\" />",
    "props": {
      "items": {
        "name": "items",
        "type": "MenuItem[]",
        "description": "@component GlimMenu @description A menu component that displays a list of selectable items. Used for dropdown menus, context menus, and other selection interfaces.  @example <GlimMenu :items=\"[{label: 'Option 1'}, {label: 'Option 2', selected: true}]\" @click=\"handleItemClick\" /> @example <GlimMenu :items=\"menuOptions\" @click=\"(item) => selectedItem = item\" /> /\n\n/   Menu item interface defining the structure of menu items /\nexport interface MenuItem {\n  /  Display text for the menu item /\n  label: string;\n  /  Whether the item is currently selected /\n  selected?: boolean;\n}\n\n/   Menu component props /\ndefineProps<{\n  /  Array of menu items to display",
        "required": true
      }
    },
    "events": {
      "click": {
        "name": "click",
        "description": "@component GlimMenu @description A menu component that displays a list of selectable items. Used for dropdown menus, context menus, and other selection interfaces.  @example <GlimMenu :items=\"[{label: 'Option 1'}, {label: 'Option 2', selected: true}]\" @click=\"handleItemClick\" /> @example <GlimMenu :items=\"menuOptions\" @click=\"(item) => selectedItem = item\" /> /\n\n/   Menu item interface defining the structure of menu items /\nexport interface MenuItem {\n  /  Display text for the menu item /\n  label: string;\n  /  Whether the item is currently selected /\n  selected?: boolean;\n}\n\n/   Menu component props /\ndefineProps<{\n  /  Array of menu items to display /\n  items: MenuItem[];\n}>();\n\n/   Menu component events /\ndefineEmits<{\n  /  Emitted when a menu item is clicked, with the selected item as payload",
        "params": [
          {
            "name": "item",
            "type": "MenuItem",
            "description": "Parameter item for the event"
          }
        ]
      }
    },
    "methods": {},
    "computed": {},
    "tokens": {
      "colors": [],
      "dimensions": [],
      "strings": []
    }
  },
  {
    "name": "GlimMessage",
    "description": "The title of the message",
    "props": {},
    "events": {},
    "methods": {
      "getIconFromVariant": {
        "name": "getIconFromVariant",
        "description": "Method getIconFromVariant",
        "params": [
          {
            "name": "(",
            "type": "any",
            "description": "Parameter ( for the method",
            "required": true
          }
        ]
      }
    },
    "computed": {
      "getIconFromVariant": {
        "name": "getIconFromVariant",
        "type": "any",
        "description": "Computed property getIconFromVariant"
      }
    },
    "tokens": {
      "colors": [],
      "dimensions": [],
      "strings": []
    }
  },
  {
    "name": "GlimProgressBar",
    "description": "@component GlimProgressBar @description A progress bar component that can show determinate progress or an indeterminate loading state",
    "props": {
      "value": {
        "name": "value",
        "type": "Number",
        "required": true,
        "default": "0",
        "description": "The value prop"
      },
      "showValue": {
        "name": "showValue",
        "type": "Boolean",
        "required": false,
        "default": "false",
        "description": "The showValue prop"
      },
      "size": {
        "name": "size",
        "type": "String",
        "required": false,
        "default": "medium",
        "description": "The size prop"
      },
      "indeterminate": {
        "name": "indeterminate",
        "type": "Boolean",
        "required": false,
        "default": "false",
        "description": "The indeterminate prop"
      },
      "height": {
        "name": "height",
        "type": "any",
        "required": false,
        "default": "8px",
        "description": "The height prop"
      }
    },
    "events": {},
    "methods": {},
    "computed": {
      "progress": {
        "name": "progress",
        "type": "any",
        "description": "Computed property progress"
      },
      "looping": {
        "name": "looping",
        "type": "any",
        "description": "Computed property looping"
      }
    },
    "tokens": {
      "colors": [],
      "dimensions": [],
      "strings": []
    }
  },
  {
    "name": "GlimSegmentedControls",
    "description": "@name GlimSegmentedControls @description A component that provides a set of mutually exclusive options, similar to radio buttons but with a cohesive, button-like appearance. Commonly used for switching between views or toggling related options.  @displayName Segmented Controls @status stable @category Input Controls  @example Basic Usage ```vue <GlimSegmentedControls v-model=\"selectedOption\" :items=\"[ { id: 'day', label: 'Day' }, { id: 'week', label: 'Week' }, { id: 'month', label: 'Month', disabled: true } ]\" size=\"default\" /> ```",
    "props": {},
    "events": {},
    "methods": {
      "updateBackgroundPosition": {
        "name": "updateBackgroundPosition",
        "description": "Method updateBackgroundPosition"
      },
      "defaultModelValue": {
        "name": "defaultModelValue",
        "description": "Method defaultModelValue",
        "params": [
          {
            "name": "(",
            "type": "any",
            "description": "Parameter ( for the method",
            "required": true
          }
        ]
      },
      "selectedValue": {
        "name": "selectedValue",
        "description": "Method selectedValue",
        "params": [
          {
            "name": "(",
            "type": "any",
            "description": "Parameter ( for the method",
            "required": true
          }
        ]
      },
      "selectSegment": {
        "name": "selectSegment",
        "description": "@name GlimSegmentedControls @description A component that provides a set of mutually exclusive options, similar to radio buttons but with a cohesive, button-like appearance. Commonly used for switching between views or toggling related options.  @displayName Segmented Controls @status stable @category Input Controls  @example Basic Usage ```vue <GlimSegmentedControls v-model=\"selectedOption\" :items=\"[ { id: 'day', label: 'Day' }, { id: 'week', label: 'Week' }, { id: 'month', label: 'Month', disabled: true } ]\" size=\"default\" /> ``` /\n\nimport { computed, onMounted, ref, watch, nextTick } from 'vue';\n\ninterface SegmentItem {\n  /   Unique identifier for the segment /\n  id: string | number;\n  \n  /   Display text for the segment /\n  label: string;\n  \n  /   Whether the segment is disabled /\n  disabled?: boolean;\n}\n\ninterface Props {\n  /   The selected value, should match an item's id /\n  modelValue: string | number | undefined;\n  \n  /   Array of items to display as segments /\n  items: Array<SegmentItem>;\n  \n  /   Size of the segmented controls @default 'default' /\n  size?: 'small' | 'default';\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  modelValue: undefined,\n  size: 'default',\n  items: () => [\n    { id: 'option1', label: 'Option 1' },\n    { id: 'option2', label: 'Option 2' },\n    { id: 'option3', label: 'Option 3' }\n  ]\n});\n\n// Compute the default value from the first item in the items array\nconst defaultModelValue = computed(() => {\n  return props.items[0]?.id || ''\n});\n\n// Use the provided model value or fall back to the default value\nconst selectedValue = computed(() => {\n  return props.modelValue === undefined ? defaultModelValue.value : props.modelValue;\n});\n\n/   Define emitted events /\nconst emit = defineEmits<{\n  /   Emitted when the selected segment changes @param value - The id of the selected segment /\n  'update:modelValue': [value: string | number];\n}>();\n\n/   Select a segment by its id @param id - The id of the segment to select",
        "params": [
          {
            "name": "id",
            "type": "string | number",
            "description": "Parameter id for the method",
            "required": true
          }
        ]
      },
      "backgroundStyle": {
        "name": "backgroundStyle",
        "description": "Method backgroundStyle",
        "params": [
          {
            "name": "(",
            "type": "any",
            "description": "Parameter ( for the method",
            "required": true
          }
        ]
      },
      "items": {
        "name": "items",
        "description": "Method items",
        "params": [
          {
            "name": "'.segmented-controls__item'",
            "type": "any",
            "description": "Parameter '.segmented-controls__item' for the method",
            "required": true
          }
        ]
      }
    },
    "computed": {
      "defaultModelValue": {
        "name": "defaultModelValue",
        "type": "any",
        "description": "Computed property defaultModelValue"
      },
      "selectedValue": {
        "name": "selectedValue",
        "type": "any",
        "description": "Computed property selectedValue"
      },
      "backgroundStyle": {
        "name": "backgroundStyle",
        "type": "any",
        "description": "Computed property backgroundStyle"
      }
    },
    "tokens": {
      "colors": [],
      "dimensions": [],
      "strings": []
    }
  },
  {
    "name": "GlimSlider",
    "description": "@component GlimSlider @description An interactive slider component for selecting a value within a range. Features a draggable thumb, visual track/rail, and tooltip showing the current value. @displayName Glim Slider @group Input Controls",
    "props": {},
    "events": {},
    "methods": {
      "percentage": {
        "name": "percentage",
        "description": "@component GlimSlider @description An interactive slider component for selecting a value within a range. Features a draggable thumb, visual track/rail, and tooltip showing the current value. @displayName Glim Slider @group Input Controls /\n\n/   @typedef {Object} SliderProps @property {number} progress - The current value of the slider @property {number} [min=0] - The minimum allowed value @property {number} [max=100] - The maximum allowed value @property {number} [step=1] - The step increment value @property {boolean} [isDisabled=false] - Whether the slider is disabled /\ninterface SliderProps {\n  /  The current value of the slider /\n  progress: number;\n  \n  /  The minimum allowed value /\n  min?: number;\n  \n  /  The maximum allowed value /\n  max?: number;\n  \n  /  The step increment value /\n  step?: number;\n  \n  /  Whether the slider is disabled /\n  isDisabled?: boolean;\n}\n\nconst props = withDefaults(defineProps<SliderProps>(), {\n  min: 0,\n  max: 100,\n  step: 1,\n  isDisabled: false\n});\n\n/   @typedef {Object} SliderEmits @property {(value: number) => void} update:progress - Emitted continuously as the slider value changes @property {(value: number) => void} change - Emitted when the user stops dragging the slider /\nconst emit = defineEmits<{\n  /  Emitted continuously as the slider value changes /\n  'update:progress': [value: number];\n  \n  /  Emitted when the user stops dragging the slider /\n  'change': [value: number];\n}>();\n\nconst internalValue = ref(props.progress);\nconst isDragging = ref(false);\nconst sliderEl = ref<HTMLElement | null>(null);\nconst railEl = ref<HTMLElement | null>(null);\n\nwatch(() => props.progress, (newVal) => {\n  internalValue.value = newVal;\n});\n\n/   Computed percentage of the current value in the range @returns {number} Percentage from 0-100",
        "params": [
          {
            "name": "(",
            "type": "any",
            "description": "Parameter ( for the method",
            "required": true
          }
        ]
      },
      "displayValue": {
        "name": "displayValue",
        "description": "@component GlimSlider @description An interactive slider component for selecting a value within a range. Features a draggable thumb, visual track/rail, and tooltip showing the current value. @displayName Glim Slider @group Input Controls /\n\n/   @typedef {Object} SliderProps @property {number} progress - The current value of the slider @property {number} [min=0] - The minimum allowed value @property {number} [max=100] - The maximum allowed value @property {number} [step=1] - The step increment value @property {boolean} [isDisabled=false] - Whether the slider is disabled /\ninterface SliderProps {\n  /  The current value of the slider /\n  progress: number;\n  \n  /  The minimum allowed value /\n  min?: number;\n  \n  /  The maximum allowed value /\n  max?: number;\n  \n  /  The step increment value /\n  step?: number;\n  \n  /  Whether the slider is disabled /\n  isDisabled?: boolean;\n}\n\nconst props = withDefaults(defineProps<SliderProps>(), {\n  min: 0,\n  max: 100,\n  step: 1,\n  isDisabled: false\n});\n\n/   @typedef {Object} SliderEmits @property {(value: number) => void} update:progress - Emitted continuously as the slider value changes @property {(value: number) => void} change - Emitted when the user stops dragging the slider /\nconst emit = defineEmits<{\n  /  Emitted continuously as the slider value changes /\n  'update:progress': [value: number];\n  \n  /  Emitted when the user stops dragging the slider /\n  'change': [value: number];\n}>();\n\nconst internalValue = ref(props.progress);\nconst isDragging = ref(false);\nconst sliderEl = ref<HTMLElement | null>(null);\nconst railEl = ref<HTMLElement | null>(null);\n\nwatch(() => props.progress, (newVal) => {\n  internalValue.value = newVal;\n});\n\n/   Computed percentage of the current value in the range @returns {number} Percentage from 0-100 /\nconst percentage = computed(() => {\n  return ((internalValue.value - props.min) / (props.max - props.min)) 100;\n});\n\n/   Computed display value (rounded) @returns {number} The rounded value to display",
        "params": [
          {
            "name": "(",
            "type": "any",
            "description": "Parameter ( for the method",
            "required": true
          }
        ]
      },
      "startDrag": {
        "name": "startDrag",
        "description": "@component GlimSlider @description An interactive slider component for selecting a value within a range. Features a draggable thumb, visual track/rail, and tooltip showing the current value. @displayName Glim Slider @group Input Controls /\n\n/   @typedef {Object} SliderProps @property {number} progress - The current value of the slider @property {number} [min=0] - The minimum allowed value @property {number} [max=100] - The maximum allowed value @property {number} [step=1] - The step increment value @property {boolean} [isDisabled=false] - Whether the slider is disabled /\ninterface SliderProps {\n  /  The current value of the slider /\n  progress: number;\n  \n  /  The minimum allowed value /\n  min?: number;\n  \n  /  The maximum allowed value /\n  max?: number;\n  \n  /  The step increment value /\n  step?: number;\n  \n  /  Whether the slider is disabled /\n  isDisabled?: boolean;\n}\n\nconst props = withDefaults(defineProps<SliderProps>(), {\n  min: 0,\n  max: 100,\n  step: 1,\n  isDisabled: false\n});\n\n/   @typedef {Object} SliderEmits @property {(value: number) => void} update:progress - Emitted continuously as the slider value changes @property {(value: number) => void} change - Emitted when the user stops dragging the slider /\nconst emit = defineEmits<{\n  /  Emitted continuously as the slider value changes /\n  'update:progress': [value: number];\n  \n  /  Emitted when the user stops dragging the slider /\n  'change': [value: number];\n}>();\n\nconst internalValue = ref(props.progress);\nconst isDragging = ref(false);\nconst sliderEl = ref<HTMLElement | null>(null);\nconst railEl = ref<HTMLElement | null>(null);\n\nwatch(() => props.progress, (newVal) => {\n  internalValue.value = newVal;\n});\n\n/   Computed percentage of the current value in the range @returns {number} Percentage from 0-100 /\nconst percentage = computed(() => {\n  return ((internalValue.value - props.min) / (props.max - props.min)) 100;\n});\n\n/   Computed display value (rounded) @returns {number} The rounded value to display /\nconst displayValue = computed(() => {\n  return Math.round(internalValue.value);\n});\n\n/   Handles the start of a drag operation @param {MouseEvent|TouchEvent} event - The mouse or touch event",
        "params": [
          {
            "name": "event",
            "type": "MouseEvent | TouchEvent",
            "description": "Parameter event for the method",
            "required": true
          }
        ]
      },
      "updateValueFromEvent": {
        "name": "updateValueFromEvent",
        "description": "@component GlimSlider @description An interactive slider component for selecting a value within a range. Features a draggable thumb, visual track/rail, and tooltip showing the current value. @displayName Glim Slider @group Input Controls /\n\n/   @typedef {Object} SliderProps @property {number} progress - The current value of the slider @property {number} [min=0] - The minimum allowed value @property {number} [max=100] - The maximum allowed value @property {number} [step=1] - The step increment value @property {boolean} [isDisabled=false] - Whether the slider is disabled /\ninterface SliderProps {\n  /  The current value of the slider /\n  progress: number;\n  \n  /  The minimum allowed value /\n  min?: number;\n  \n  /  The maximum allowed value /\n  max?: number;\n  \n  /  The step increment value /\n  step?: number;\n  \n  /  Whether the slider is disabled /\n  isDisabled?: boolean;\n}\n\nconst props = withDefaults(defineProps<SliderProps>(), {\n  min: 0,\n  max: 100,\n  step: 1,\n  isDisabled: false\n});\n\n/   @typedef {Object} SliderEmits @property {(value: number) => void} update:progress - Emitted continuously as the slider value changes @property {(value: number) => void} change - Emitted when the user stops dragging the slider /\nconst emit = defineEmits<{\n  /  Emitted continuously as the slider value changes /\n  'update:progress': [value: number];\n  \n  /  Emitted when the user stops dragging the slider /\n  'change': [value: number];\n}>();\n\nconst internalValue = ref(props.progress);\nconst isDragging = ref(false);\nconst sliderEl = ref<HTMLElement | null>(null);\nconst railEl = ref<HTMLElement | null>(null);\n\nwatch(() => props.progress, (newVal) => {\n  internalValue.value = newVal;\n});\n\n/   Computed percentage of the current value in the range @returns {number} Percentage from 0-100 /\nconst percentage = computed(() => {\n  return ((internalValue.value - props.min) / (props.max - props.min)) 100;\n});\n\n/   Computed display value (rounded) @returns {number} The rounded value to display /\nconst displayValue = computed(() => {\n  return Math.round(internalValue.value);\n});\n\n/   Handles the start of a drag operation @param {MouseEvent|TouchEvent} event - The mouse or touch event /\nconst startDrag = (event: MouseEvent | TouchEvent) => {\n  if (props.isDisabled) return;\n  \n  event.preventDefault();\n  isDragging.value = true;\n  \n  updateValueFromEvent(event);\n  \n  document.addEventListener('mousemove', onDrag);\n  document.addEventListener('touchmove', onDrag, { passive: false });\n  document.addEventListener('mouseup', stopDrag);\n  document.addEventListener('touchend', stopDrag);\n};\n\n/   Updates the slider value based on the current pointer position @param {MouseEvent|TouchEvent} event - The mouse or touch event",
        "params": [
          {
            "name": "event",
            "type": "MouseEvent | TouchEvent",
            "description": "Parameter event for the method",
            "required": true
          }
        ]
      },
      "onDrag": {
        "name": "onDrag",
        "description": "@component GlimSlider @description An interactive slider component for selecting a value within a range. Features a draggable thumb, visual track/rail, and tooltip showing the current value. @displayName Glim Slider @group Input Controls /\n\n/   @typedef {Object} SliderProps @property {number} progress - The current value of the slider @property {number} [min=0] - The minimum allowed value @property {number} [max=100] - The maximum allowed value @property {number} [step=1] - The step increment value @property {boolean} [isDisabled=false] - Whether the slider is disabled /\ninterface SliderProps {\n  /  The current value of the slider /\n  progress: number;\n  \n  /  The minimum allowed value /\n  min?: number;\n  \n  /  The maximum allowed value /\n  max?: number;\n  \n  /  The step increment value /\n  step?: number;\n  \n  /  Whether the slider is disabled /\n  isDisabled?: boolean;\n}\n\nconst props = withDefaults(defineProps<SliderProps>(), {\n  min: 0,\n  max: 100,\n  step: 1,\n  isDisabled: false\n});\n\n/   @typedef {Object} SliderEmits @property {(value: number) => void} update:progress - Emitted continuously as the slider value changes @property {(value: number) => void} change - Emitted when the user stops dragging the slider /\nconst emit = defineEmits<{\n  /  Emitted continuously as the slider value changes /\n  'update:progress': [value: number];\n  \n  /  Emitted when the user stops dragging the slider /\n  'change': [value: number];\n}>();\n\nconst internalValue = ref(props.progress);\nconst isDragging = ref(false);\nconst sliderEl = ref<HTMLElement | null>(null);\nconst railEl = ref<HTMLElement | null>(null);\n\nwatch(() => props.progress, (newVal) => {\n  internalValue.value = newVal;\n});\n\n/   Computed percentage of the current value in the range @returns {number} Percentage from 0-100 /\nconst percentage = computed(() => {\n  return ((internalValue.value - props.min) / (props.max - props.min)) 100;\n});\n\n/   Computed display value (rounded) @returns {number} The rounded value to display /\nconst displayValue = computed(() => {\n  return Math.round(internalValue.value);\n});\n\n/   Handles the start of a drag operation @param {MouseEvent|TouchEvent} event - The mouse or touch event /\nconst startDrag = (event: MouseEvent | TouchEvent) => {\n  if (props.isDisabled) return;\n  \n  event.preventDefault();\n  isDragging.value = true;\n  \n  updateValueFromEvent(event);\n  \n  document.addEventListener('mousemove', onDrag);\n  document.addEventListener('touchmove', onDrag, { passive: false });\n  document.addEventListener('mouseup', stopDrag);\n  document.addEventListener('touchend', stopDrag);\n};\n\n/   Updates the slider value based on the current pointer position @param {MouseEvent|TouchEvent} event - The mouse or touch event /\nconst updateValueFromEvent = (event: MouseEvent | TouchEvent) => {\n  if (!railEl.value) return;\n  \n  const rect = railEl.value.getBoundingClientRect();\n  \n  let clientX: number;\n  if ('clientX' in event) {\n    clientX = event.clientX;\n  } else {\n    clientX = event.touches[0].clientX;\n  }\n  \n  let position = (clientX - rect.left) / rect.width;\n  position = Math.max(0, Math.min(position, 1));\n  \n  const newValue = props.min + position (props.max - props.min);\n  const steppedValue = Math.round(newValue / props.step) props.step;\n  const clampedValue = Math.max(props.min, Math.min(props.max, steppedValue));\n  \n  internalValue.value = clampedValue;\n  emit('update:progress', clampedValue);\n};\n\n/   Handles the drag movement @param {MouseEvent|TouchEvent} event - The mouse or touch event",
        "params": [
          {
            "name": "event",
            "type": "MouseEvent | TouchEvent",
            "description": "Parameter event for the method",
            "required": true
          }
        ]
      },
      "stopDrag": {
        "name": "stopDrag",
        "description": "@component GlimSlider @description An interactive slider component for selecting a value within a range. Features a draggable thumb, visual track/rail, and tooltip showing the current value. @displayName Glim Slider @group Input Controls /\n\n/   @typedef {Object} SliderProps @property {number} progress - The current value of the slider @property {number} [min=0] - The minimum allowed value @property {number} [max=100] - The maximum allowed value @property {number} [step=1] - The step increment value @property {boolean} [isDisabled=false] - Whether the slider is disabled /\ninterface SliderProps {\n  /  The current value of the slider /\n  progress: number;\n  \n  /  The minimum allowed value /\n  min?: number;\n  \n  /  The maximum allowed value /\n  max?: number;\n  \n  /  The step increment value /\n  step?: number;\n  \n  /  Whether the slider is disabled /\n  isDisabled?: boolean;\n}\n\nconst props = withDefaults(defineProps<SliderProps>(), {\n  min: 0,\n  max: 100,\n  step: 1,\n  isDisabled: false\n});\n\n/   @typedef {Object} SliderEmits @property {(value: number) => void} update:progress - Emitted continuously as the slider value changes @property {(value: number) => void} change - Emitted when the user stops dragging the slider /\nconst emit = defineEmits<{\n  /  Emitted continuously as the slider value changes /\n  'update:progress': [value: number];\n  \n  /  Emitted when the user stops dragging the slider /\n  'change': [value: number];\n}>();\n\nconst internalValue = ref(props.progress);\nconst isDragging = ref(false);\nconst sliderEl = ref<HTMLElement | null>(null);\nconst railEl = ref<HTMLElement | null>(null);\n\nwatch(() => props.progress, (newVal) => {\n  internalValue.value = newVal;\n});\n\n/   Computed percentage of the current value in the range @returns {number} Percentage from 0-100 /\nconst percentage = computed(() => {\n  return ((internalValue.value - props.min) / (props.max - props.min)) 100;\n});\n\n/   Computed display value (rounded) @returns {number} The rounded value to display /\nconst displayValue = computed(() => {\n  return Math.round(internalValue.value);\n});\n\n/   Handles the start of a drag operation @param {MouseEvent|TouchEvent} event - The mouse or touch event /\nconst startDrag = (event: MouseEvent | TouchEvent) => {\n  if (props.isDisabled) return;\n  \n  event.preventDefault();\n  isDragging.value = true;\n  \n  updateValueFromEvent(event);\n  \n  document.addEventListener('mousemove', onDrag);\n  document.addEventListener('touchmove', onDrag, { passive: false });\n  document.addEventListener('mouseup', stopDrag);\n  document.addEventListener('touchend', stopDrag);\n};\n\n/   Updates the slider value based on the current pointer position @param {MouseEvent|TouchEvent} event - The mouse or touch event /\nconst updateValueFromEvent = (event: MouseEvent | TouchEvent) => {\n  if (!railEl.value) return;\n  \n  const rect = railEl.value.getBoundingClientRect();\n  \n  let clientX: number;\n  if ('clientX' in event) {\n    clientX = event.clientX;\n  } else {\n    clientX = event.touches[0].clientX;\n  }\n  \n  let position = (clientX - rect.left) / rect.width;\n  position = Math.max(0, Math.min(position, 1));\n  \n  const newValue = props.min + position (props.max - props.min);\n  const steppedValue = Math.round(newValue / props.step) props.step;\n  const clampedValue = Math.max(props.min, Math.min(props.max, steppedValue));\n  \n  internalValue.value = clampedValue;\n  emit('update:progress', clampedValue);\n};\n\n/   Handles the drag movement @param {MouseEvent|TouchEvent} event - The mouse or touch event /\nconst onDrag = (event: MouseEvent | TouchEvent) => {\n  if (!isDragging.value) return;\n  \n  if ('touches' in event) {\n    event.preventDefault();\n  }\n  \n  updateValueFromEvent(event);\n};\n\n/   Stops the dragging operation and cleans up event listeners"
      }
    },
    "computed": {
      "percentage": {
        "name": "percentage",
        "type": "any",
        "description": "@component GlimSlider @description An interactive slider component for selecting a value within a range. Features a draggable thumb, visual track/rail, and tooltip showing the current value. @displayName Glim Slider @group Input Controls /\n\n/   @typedef {Object} SliderProps @property {number} progress - The current value of the slider @property {number} [min=0] - The minimum allowed value @property {number} [max=100] - The maximum allowed value @property {number} [step=1] - The step increment value @property {boolean} [isDisabled=false] - Whether the slider is disabled /\ninterface SliderProps {\n  /  The current value of the slider /\n  progress: number;\n  \n  /  The minimum allowed value /\n  min?: number;\n  \n  /  The maximum allowed value /\n  max?: number;\n  \n  /  The step increment value /\n  step?: number;\n  \n  /  Whether the slider is disabled /\n  isDisabled?: boolean;\n}\n\nconst props = withDefaults(defineProps<SliderProps>(), {\n  min: 0,\n  max: 100,\n  step: 1,\n  isDisabled: false\n});\n\n/   @typedef {Object} SliderEmits @property {(value: number) => void} update:progress - Emitted continuously as the slider value changes @property {(value: number) => void} change - Emitted when the user stops dragging the slider /\nconst emit = defineEmits<{\n  /  Emitted continuously as the slider value changes /\n  'update:progress': [value: number];\n  \n  /  Emitted when the user stops dragging the slider /\n  'change': [value: number];\n}>();\n\nconst internalValue = ref(props.progress);\nconst isDragging = ref(false);\nconst sliderEl = ref<HTMLElement | null>(null);\nconst railEl = ref<HTMLElement | null>(null);\n\nwatch(() => props.progress, (newVal) => {\n  internalValue.value = newVal;\n});\n\n/   Computed percentage of the current value in the range @returns {number} Percentage from 0-100"
      },
      "displayValue": {
        "name": "displayValue",
        "type": "any",
        "description": "@component GlimSlider @description An interactive slider component for selecting a value within a range. Features a draggable thumb, visual track/rail, and tooltip showing the current value. @displayName Glim Slider @group Input Controls /\n\n/   @typedef {Object} SliderProps @property {number} progress - The current value of the slider @property {number} [min=0] - The minimum allowed value @property {number} [max=100] - The maximum allowed value @property {number} [step=1] - The step increment value @property {boolean} [isDisabled=false] - Whether the slider is disabled /\ninterface SliderProps {\n  /  The current value of the slider /\n  progress: number;\n  \n  /  The minimum allowed value /\n  min?: number;\n  \n  /  The maximum allowed value /\n  max?: number;\n  \n  /  The step increment value /\n  step?: number;\n  \n  /  Whether the slider is disabled /\n  isDisabled?: boolean;\n}\n\nconst props = withDefaults(defineProps<SliderProps>(), {\n  min: 0,\n  max: 100,\n  step: 1,\n  isDisabled: false\n});\n\n/   @typedef {Object} SliderEmits @property {(value: number) => void} update:progress - Emitted continuously as the slider value changes @property {(value: number) => void} change - Emitted when the user stops dragging the slider /\nconst emit = defineEmits<{\n  /  Emitted continuously as the slider value changes /\n  'update:progress': [value: number];\n  \n  /  Emitted when the user stops dragging the slider /\n  'change': [value: number];\n}>();\n\nconst internalValue = ref(props.progress);\nconst isDragging = ref(false);\nconst sliderEl = ref<HTMLElement | null>(null);\nconst railEl = ref<HTMLElement | null>(null);\n\nwatch(() => props.progress, (newVal) => {\n  internalValue.value = newVal;\n});\n\n/   Computed percentage of the current value in the range @returns {number} Percentage from 0-100 /\nconst percentage = computed(() => {\n  return ((internalValue.value - props.min) / (props.max - props.min)) 100;\n});\n\n/   Computed display value (rounded) @returns {number} The rounded value to display"
      }
    },
    "tokens": {
      "colors": [],
      "dimensions": [],
      "strings": []
    }
  },
  {
    "name": "GlimSpinner",
    "description": "@component GlimSpinner @description A loading spinner component that provides visual feedback during asynchronous operations. The spinner can be customized with different sizes and colors.  @example <GlimSpinner /> @example <GlimSpinner size=\"32px\" color=\"var(--glim-color-primary)\" /> @example <GlimSpinner size=\"16\" color=\"#ff0000\" />",
    "props": {
      "size": {
        "name": "size",
        "type": "any",
        "required": false,
        "default": "24",
        "description": "The size prop"
      },
      "color": {
        "name": "color",
        "type": "String",
        "required": false,
        "default": "currentColor",
        "description": "The color prop"
      }
    },
    "events": {},
    "methods": {},
    "computed": {},
    "tokens": {
      "colors": [],
      "dimensions": [],
      "strings": []
    }
  },
  {
    "name": "GlimTabs",
    "description": "@name GlimTabs @description A tabbed interface component that allows switching between different content sections. Features an animated indicator that follows the selected tab.  @example <GlimTabs v-model=\"activeTab\" :items=\"[{id: 'tab1', label: 'First Tab'}, {id: 'tab2', label: 'Second Tab'}]\" /> @example <GlimTabs v-model=\"activeSection\" :items=\"tabs\" /> @example <GlimTabs v-model=\"view\" :items=\"[{id: 1, label: 'Details'}, {id: 2, label: 'Reviews', disabled: true}]\" />  @vue-prop {string|number} modelValue - Currently selected tab ID (v-model) @vue-prop {TabItem[]} items - Array of tab items to display  @vue-event {string|number} update:modelValue - Emitted when a tab is selected",
    "props": {},
    "events": {},
    "methods": {
      "defaultModelValue": {
        "name": "defaultModelValue",
        "description": "@name GlimTabs @description A tabbed interface component that allows switching between different content sections. Features an animated indicator that follows the selected tab.  @example <GlimTabs v-model=\"activeTab\" :items=\"[{id: 'tab1', label: 'First Tab'}, {id: 'tab2', label: 'Second Tab'}]\" /> @example <GlimTabs v-model=\"activeSection\" :items=\"tabs\" /> @example <GlimTabs v-model=\"view\" :items=\"[{id: 1, label: 'Details'}, {id: 2, label: 'Reviews', disabled: true}]\" />  @vue-prop {string|number} modelValue - Currently selected tab ID (v-model) @vue-prop {TabItem[]} items - Array of tab items to display  @vue-event {string|number} update:modelValue - Emitted when a tab is selected /\n\n/   Tab item interface @typedef {Object} TabItem @property {string|number} id - Unique identifier for the tab @property {string} label - Display text for the tab @property {boolean} [disabled] - Whether the tab is disabled /\ninterface TabItem {\n  id: string | number;\n  label: string;\n  disabled?: boolean;\n}\n\ninterface Props {\n  /   Currently selected tab ID (v-model) /\n  modelValue: string | number;\n  \n  /   Array of tab items to display /\n  items: TabItem[];\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  modelValue: 'tab1',\n  items: () => [\n    { id: 'tab1', label: 'Tab 1' },\n    { id: 'tab2', label: 'Tab 2' },\n    { id: 'tab3', label: 'Tab 3' }\n  ]\n});\n\nconst emit = defineEmits<{\n  'update:modelValue': [value: string | number];\n}>();\n\n/   Add computed property for default value",
        "params": [
          {
            "name": "(",
            "type": "any",
            "description": "Parameter ( for the method",
            "required": true
          }
        ]
      },
      "selectedTab": {
        "name": "selectedTab",
        "description": "@name GlimTabs @description A tabbed interface component that allows switching between different content sections. Features an animated indicator that follows the selected tab.  @example <GlimTabs v-model=\"activeTab\" :items=\"[{id: 'tab1', label: 'First Tab'}, {id: 'tab2', label: 'Second Tab'}]\" /> @example <GlimTabs v-model=\"activeSection\" :items=\"tabs\" /> @example <GlimTabs v-model=\"view\" :items=\"[{id: 1, label: 'Details'}, {id: 2, label: 'Reviews', disabled: true}]\" />  @vue-prop {string|number} modelValue - Currently selected tab ID (v-model) @vue-prop {TabItem[]} items - Array of tab items to display  @vue-event {string|number} update:modelValue - Emitted when a tab is selected /\n\n/   Tab item interface @typedef {Object} TabItem @property {string|number} id - Unique identifier for the tab @property {string} label - Display text for the tab @property {boolean} [disabled] - Whether the tab is disabled /\ninterface TabItem {\n  id: string | number;\n  label: string;\n  disabled?: boolean;\n}\n\ninterface Props {\n  /   Currently selected tab ID (v-model) /\n  modelValue: string | number;\n  \n  /   Array of tab items to display /\n  items: TabItem[];\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  modelValue: 'tab1',\n  items: () => [\n    { id: 'tab1', label: 'Tab 1' },\n    { id: 'tab2', label: 'Tab 2' },\n    { id: 'tab3', label: 'Tab 3' }\n  ]\n});\n\nconst emit = defineEmits<{\n  'update:modelValue': [value: string | number];\n}>();\n\n/   Add computed property for default value /\nconst defaultModelValue = computed(() => {\n  return props.items[0]?.id || 'tab1'\n})\n\n/   Computed value to ensure consistent type handling",
        "params": [
          {
            "name": "(",
            "type": "any",
            "description": "Parameter ( for the method",
            "required": true
          }
        ]
      },
      "selectTab": {
        "name": "selectTab",
        "description": "@name GlimTabs @description A tabbed interface component that allows switching between different content sections. Features an animated indicator that follows the selected tab.  @example <GlimTabs v-model=\"activeTab\" :items=\"[{id: 'tab1', label: 'First Tab'}, {id: 'tab2', label: 'Second Tab'}]\" /> @example <GlimTabs v-model=\"activeSection\" :items=\"tabs\" /> @example <GlimTabs v-model=\"view\" :items=\"[{id: 1, label: 'Details'}, {id: 2, label: 'Reviews', disabled: true}]\" />  @vue-prop {string|number} modelValue - Currently selected tab ID (v-model) @vue-prop {TabItem[]} items - Array of tab items to display  @vue-event {string|number} update:modelValue - Emitted when a tab is selected /\n\n/   Tab item interface @typedef {Object} TabItem @property {string|number} id - Unique identifier for the tab @property {string} label - Display text for the tab @property {boolean} [disabled] - Whether the tab is disabled /\ninterface TabItem {\n  id: string | number;\n  label: string;\n  disabled?: boolean;\n}\n\ninterface Props {\n  /   Currently selected tab ID (v-model) /\n  modelValue: string | number;\n  \n  /   Array of tab items to display /\n  items: TabItem[];\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  modelValue: 'tab1',\n  items: () => [\n    { id: 'tab1', label: 'Tab 1' },\n    { id: 'tab2', label: 'Tab 2' },\n    { id: 'tab3', label: 'Tab 3' }\n  ]\n});\n\nconst emit = defineEmits<{\n  'update:modelValue': [value: string | number];\n}>();\n\n/   Add computed property for default value /\nconst defaultModelValue = computed(() => {\n  return props.items[0]?.id || 'tab1'\n})\n\n/   Computed value to ensure consistent type handling /\nconst selectedTab = computed(() => {\n  // If modelValue is undefined, use the first item's id\n  if (props.modelValue === undefined) {\n    return defaultModelValue.value\n  }\n  // If items are numbers, convert modelValue to number\n  if (props.items.length > 0 && typeof props.items[0].id === 'number') {\n    return Number(props.modelValue)\n  }\n  return String(props.modelValue)\n});\n\n/   Selects a tab by its ID and emits the update event Does nothing if the tab is disabled @param {string|number} id - ID of the tab to select",
        "params": [
          {
            "name": "id",
            "type": "string | number",
            "description": "Parameter id for the method",
            "required": true
          }
        ]
      }
    },
    "computed": {
      "defaultModelValue": {
        "name": "defaultModelValue",
        "type": "any",
        "description": "@name GlimTabs @description A tabbed interface component that allows switching between different content sections. Features an animated indicator that follows the selected tab.  @example <GlimTabs v-model=\"activeTab\" :items=\"[{id: 'tab1', label: 'First Tab'}, {id: 'tab2', label: 'Second Tab'}]\" /> @example <GlimTabs v-model=\"activeSection\" :items=\"tabs\" /> @example <GlimTabs v-model=\"view\" :items=\"[{id: 1, label: 'Details'}, {id: 2, label: 'Reviews', disabled: true}]\" />  @vue-prop {string|number} modelValue - Currently selected tab ID (v-model) @vue-prop {TabItem[]} items - Array of tab items to display  @vue-event {string|number} update:modelValue - Emitted when a tab is selected /\n\n/   Tab item interface @typedef {Object} TabItem @property {string|number} id - Unique identifier for the tab @property {string} label - Display text for the tab @property {boolean} [disabled] - Whether the tab is disabled /\ninterface TabItem {\n  id: string | number;\n  label: string;\n  disabled?: boolean;\n}\n\ninterface Props {\n  /   Currently selected tab ID (v-model) /\n  modelValue: string | number;\n  \n  /   Array of tab items to display /\n  items: TabItem[];\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  modelValue: 'tab1',\n  items: () => [\n    { id: 'tab1', label: 'Tab 1' },\n    { id: 'tab2', label: 'Tab 2' },\n    { id: 'tab3', label: 'Tab 3' }\n  ]\n});\n\nconst emit = defineEmits<{\n  'update:modelValue': [value: string | number];\n}>();\n\n/   Add computed property for default value"
      },
      "selectedTab": {
        "name": "selectedTab",
        "type": "any",
        "description": "@name GlimTabs @description A tabbed interface component that allows switching between different content sections. Features an animated indicator that follows the selected tab.  @example <GlimTabs v-model=\"activeTab\" :items=\"[{id: 'tab1', label: 'First Tab'}, {id: 'tab2', label: 'Second Tab'}]\" /> @example <GlimTabs v-model=\"activeSection\" :items=\"tabs\" /> @example <GlimTabs v-model=\"view\" :items=\"[{id: 1, label: 'Details'}, {id: 2, label: 'Reviews', disabled: true}]\" />  @vue-prop {string|number} modelValue - Currently selected tab ID (v-model) @vue-prop {TabItem[]} items - Array of tab items to display  @vue-event {string|number} update:modelValue - Emitted when a tab is selected /\n\n/   Tab item interface @typedef {Object} TabItem @property {string|number} id - Unique identifier for the tab @property {string} label - Display text for the tab @property {boolean} [disabled] - Whether the tab is disabled /\ninterface TabItem {\n  id: string | number;\n  label: string;\n  disabled?: boolean;\n}\n\ninterface Props {\n  /   Currently selected tab ID (v-model) /\n  modelValue: string | number;\n  \n  /   Array of tab items to display /\n  items: TabItem[];\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  modelValue: 'tab1',\n  items: () => [\n    { id: 'tab1', label: 'Tab 1' },\n    { id: 'tab2', label: 'Tab 2' },\n    { id: 'tab3', label: 'Tab 3' }\n  ]\n});\n\nconst emit = defineEmits<{\n  'update:modelValue': [value: string | number];\n}>();\n\n/   Add computed property for default value /\nconst defaultModelValue = computed(() => {\n  return props.items[0]?.id || 'tab1'\n})\n\n/   Computed value to ensure consistent type handling"
      }
    },
    "tokens": {
      "colors": [],
      "dimensions": [],
      "strings": []
    }
  },
  {
    "name": "GlimToggle",
    "description": "@component GlimToggle @description A toggle switch component for boolean inputs, similar to a checkbox but with a sliding visual design. Used for enabling/disabling settings or features.  @example <GlimToggle v-model=\"enabled\" /> @example <GlimToggle v-model=\"darkMode\" size=\"small\" /> @example <GlimToggle v-model=\"notifications\" disabled />",
    "props": {},
    "events": {},
    "methods": {
      "isActive": {
        "name": "isActive",
        "description": "@component GlimToggle @description A toggle switch component for boolean inputs, similar to a checkbox but with a sliding visual design. Used for enabling/disabling settings or features.  @example <GlimToggle v-model=\"enabled\" /> @example <GlimToggle v-model=\"darkMode\" size=\"small\" /> @example <GlimToggle v-model=\"notifications\" disabled /> /\n\nimport { computed } from 'vue';\n\n/   @prop modelValue - Current state of the toggle (v-model) @prop disabled - Whether the toggle is disabled @prop size - Size variant for the toggle /\ninterface Props {\n  /   Current state of the toggle @type {boolean|string} @required /\n  modelValue: boolean | string;\n  \n  /   Whether the toggle is disabled @type {boolean} @default false /\n  disabled?: boolean;\n  \n  /   Size variant for the toggle @type {'small'|'default'} @default 'default' /\n  size?: 'small' | 'default';\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  disabled: false,\n  size: 'default'\n});\n\n/   @event update:modelValue - Emitted when the toggle state changes /\nconst emit = defineEmits<{\n  'update:modelValue': [value: boolean];\n}>();\n\n/   Computed value to handle both boolean and string inputs",
        "params": [
          {
            "name": "(",
            "type": "any",
            "description": "Parameter ( for the method",
            "required": true
          }
        ]
      },
      "toggle": {
        "name": "toggle",
        "description": "@component GlimToggle @description A toggle switch component for boolean inputs, similar to a checkbox but with a sliding visual design. Used for enabling/disabling settings or features.  @example <GlimToggle v-model=\"enabled\" /> @example <GlimToggle v-model=\"darkMode\" size=\"small\" /> @example <GlimToggle v-model=\"notifications\" disabled /> /\n\nimport { computed } from 'vue';\n\n/   @prop modelValue - Current state of the toggle (v-model) @prop disabled - Whether the toggle is disabled @prop size - Size variant for the toggle /\ninterface Props {\n  /   Current state of the toggle @type {boolean|string} @required /\n  modelValue: boolean | string;\n  \n  /   Whether the toggle is disabled @type {boolean} @default false /\n  disabled?: boolean;\n  \n  /   Size variant for the toggle @type {'small'|'default'} @default 'default' /\n  size?: 'small' | 'default';\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  disabled: false,\n  size: 'default'\n});\n\n/   @event update:modelValue - Emitted when the toggle state changes /\nconst emit = defineEmits<{\n  'update:modelValue': [value: boolean];\n}>();\n\n/   Computed value to handle both boolean and string inputs /\nconst isActive = computed(() => {\n  if (typeof props.modelValue === 'string') {\n    return props.modelValue === 'true';\n  }\n  return props.modelValue;\n});\n\n/   Toggles the switch state when clicked Does nothing if the toggle is disabled"
      }
    },
    "computed": {
      "isActive": {
        "name": "isActive",
        "type": "any",
        "description": "@component GlimToggle @description A toggle switch component for boolean inputs, similar to a checkbox but with a sliding visual design. Used for enabling/disabling settings or features.  @example <GlimToggle v-model=\"enabled\" /> @example <GlimToggle v-model=\"darkMode\" size=\"small\" /> @example <GlimToggle v-model=\"notifications\" disabled /> /\n\nimport { computed } from 'vue';\n\n/   @prop modelValue - Current state of the toggle (v-model) @prop disabled - Whether the toggle is disabled @prop size - Size variant for the toggle /\ninterface Props {\n  /   Current state of the toggle @type {boolean|string} @required /\n  modelValue: boolean | string;\n  \n  /   Whether the toggle is disabled @type {boolean} @default false /\n  disabled?: boolean;\n  \n  /   Size variant for the toggle @type {'small'|'default'} @default 'default' /\n  size?: 'small' | 'default';\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  disabled: false,\n  size: 'default'\n});\n\n/   @event update:modelValue - Emitted when the toggle state changes /\nconst emit = defineEmits<{\n  'update:modelValue': [value: boolean];\n}>();\n\n/   Computed value to handle both boolean and string inputs"
      }
    },
    "tokens": {
      "colors": [],
      "dimensions": [],
      "strings": []
    }
  },
  {
    "name": "GlimTooltip",
    "description": "@component GlimTooltip @description A tooltip component that displays additional information when hovering over or focusing on an element. Tooltips can be positioned in different directions and can contain text or custom content. @example <GlimTooltip text=\"This is a tooltip\" position=\"top\" :visible=\"visible\" /> @example <GlimTooltip position=\"bottom\" :visible=\"showHelp\"><span>Custom tooltip content</span></GlimTooltip> @example <GlimTooltip position=\"left\" :visible=\"true\">Help text with <strong>formatting</strong></GlimTooltip>",
    "props": {},
    "events": {},
    "methods": {},
    "computed": {},
    "tokens": {
      "colors": [],
      "dimensions": [],
      "strings": []
    }
  }
]